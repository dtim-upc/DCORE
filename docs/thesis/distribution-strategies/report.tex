
\documentclass[12pt, a4paper]{article}

\input{preamble}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{TODO}
\lhead{TODO}
\rfoot{Page \thepage}

\title{%
  \vspace{-10ex}
  Maximal Matches Disjoint Enumeration
}
\author{%
  Arnau Abella \\
  \large{Universitat Polit\`ecnica de Catalunya}
}
\date{\today}

\begin{document}
\maketitle
% \tableofcontents

%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}

On one hand, CORE's evaluation algorithm guarantees \textit{output-linear} delay enumeration of the output \cite{core}.
Although each enumeration can be accomplished in linear time with respect to the size of the complex event,
the cost of enumerating all complex events from a CEQL that contains an iteration clause is exponential \textit{w.r.t} the size of this clause \cite{grez_et_al:LIPIcs:2019:10307}.

Selection strategies (\textit{STRICT}, \textit{NXT}, \textit{LAST}, \textit{MAX}) were created to restrict the size of the output set.
In the case of CORE, this bounds the execution time of the enumeration process.
However, all four selection strategies still suffer exponential growth complexity in the presence of iterations.

\section{Algorithm}
\label{sec:algorithm}

In order to deal with the exponential complexity of enumerating all submatches of a query that contains multiple iteration patterns, we propose the distributed enumeration algorithm \gls{mmde}.

The algorithms presented in \textit{CORE: a COmplex event Recognition Engine} are based on the well-founded complex event semantics $\llbracket \varphi \rrbracket (S) := \{ C_{V} \ | \ V \in \llceil \varphi \rrfloor (S) \}$. But, the algorithms of this section are based on the definition of match (\ref{def:match}) and maximal match (\ref{def:maximalmatch}) which are both data structures produced by CORE (the engine).

\begin{definition}[Match]
  \label{def:match}
  TODO
\end{definition}

\begin{definition}[Maximal Match]
  \label{def:maximalmatch}
  TODO
\end{definition}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoLine
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{MMDE}{\textsc{MaximalMatchesDisjointEnumeration}}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}

  \Procedure{\MMDE{$M$, $W$}}{
    \KwIn{A set of maximal matches $M := \{M_{1}, \ldots, M_{n}\}$ \newline
      and a set of workers $W := \{w_{1},\ldots, w_{m}\}$
    }
    \KwResult{Enumerates all \textit{submatches} $\subseteq M$ without repetitions}
    $C \leftarrow \emptyset$\;
    \For{$M_{i} \in M$}{
        $C' \leftarrow \textsc{Configurations}(M_{i}).map(\lambda c \to \langle c, M_{i} \rangle)$\;
        $C \leftarrow C \cup C'$\;
    }
    $D \leftarrow C.groupBy(fst)$\tcp*[l]{\textit{fst} returns the first element of a tuple}
    $\textsc{Distribute}(W, D)$\tcp*[l]{Distribute each tuple $\langle c, \{ M_{i}, \ldots, M_{j}\} \rangle \in D$ among workers $W$}
    \For{$w \in W$}{
      \tcp{\textsc{Enumerate} is executed in a remote machine}
      $w.\textsc{Enumerate}()$
    }
  }
  \;

  \Procedure{\Enumerate{}}{
    \KwData{A set of tuples $A = \{ \langle c, \{ M_{1}, \ldots, M_{n}\} \rangle \}$ where $c$ is a configuration and $M_{i}$ are maximal matches}
    \KwOut{The set of all submatches without repetitions}
    $S \leftarrow \emptyset$\;
    \For(\tcp*[h]{$M = \{ M_{1}, \ldots, M_{n}\}$}){$\langle c, M\rangle \in A$}{
      $T \leftarrow \textsc{Root}$\tcp*[l]{Root of a n-ary tree}
      \For{$M_{i} \in M$}{
        \For\tcp*[h]{$e$ is an event}{$e \in M_{i}$}{
          % A <- takeWhile(\lambda e_{i} -> e_{i}.type = e.type)
          % k <- c(B.type)
          % B <- \binom{A}{k}
          %
        }
      }
    }
  }
  \;
\caption{\glsentrylong{mmde}}
\label{algo:mmde}
\end{algorithm}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoLine
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Configurations}{\textsc{Configurations}}

  \Procedure{\Configurations{$M$}}{
    \KwIn{A match $M = \{e_{1}, \ldots, e_{n}\}$ where $e_{i}$ is an event of type $t \in T$}
    \KwOut{A set $CC$ of configurations $C := T \times \mathbb{N}$ where $C$ is the mapping from the event type $t \in T$ to the size of the iteration of the event type $t$ in the submatches of $M$}
    $T \leftarrow types(M)$\tcp*[l]{Ordered set of types e.g. $types(A_{1}A_{2}B_{1}C_{1}) = \{A,B,C\}$}
    $V \leftarrow newList$\;
    $e_{0} \leftarrow pop(M)$\;
    $A \leftarrow \{ e_{0} \}$\;
    $A.type \leftarrow e_{0}.type$\;
    \For{event $e$ in $M$}{
      \eIf{$e.type = A.type$}{
        $A \leftarrow A \cup e$\;
        \uIf{$isLast(e)$} {
          $V \leftarrow V + enumFromTo(1, |A|)$
        }
      }{
        $V \leftarrow V + enumFromTo(1, |A|)$\;
        $A \leftarrow \{ e \}$\;
        $A.type \leftarrow e.type$\;
      }
    }
    $WW \leftarrow V_{1} \times \cdots \times V_{n}$\;
    $C \leftarrow \emptyset$\;
    \For{$W \in WW$}{
      $c \leftarrow \emptyset$\;
      \For{$w_{i} \in W$}{
        $c \leftarrow c \cup (t_{i}, w_{i})$ where $t_{i} \in T$\;
      }
      $C \leftarrow C \cup c$\;
    }
    \Return{C}
  }
\caption{\textsc{Configurations}}
\label{algo:configurations}
\end{algorithm}

\subsection{Proof}
\label{subsec:proof}

You need to make the following observations of "Maximal Matches Enumeration":
1. The algorithm produces disjoint submatches given a maximal match.
2. The algorithm produces non-disjoint submatches given multiple maximal matches.

But (2) can be analyzed further:
1. Disjoint configurations produce disjoint submatches.
2. Non-disjoint configurations produce non-disjoint submatches.

From previous observations we can conclude that repeated submatches are only generated by applying the same configuration to different maximal matches.

We propose the following algorithm:
1. (1.1),(1.2),(1.3) and (1.4) as in "Maximal Matches Enumeration"
2. Group pairs from (1) by configuration: <configuration, {maximal matches}>
3. Distribute pairs from (2). Each configuration is assigned to a single worker.
4. Enumerate submatches at worker. The output must be a set since enumeration may generated repeated outputs.

Uniqueness of submatches is guaranteed by (3) and (4).
(3) guarantees that the output of each worker is disjoint wrt the others.
(4) guarantees that the output of a worker is disjoint.

The complexity of the algorithm remains the same if we accomplish linear time enumeration in each worker (this is the tricky part).

\begin{lemma}[TODO]
  \label{lemma:todo}
  TODO
\end{lemma}

\begin{theorem}[TODO]
  \label{theorem:todo}
  TODO
\end{theorem}

\begin{example}[TODO]
  \label{example:todo}
  TODO
\end{example}

%%%%%%%%%%%%%% BIBLIOGRAPHY %%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrv}
\bibliography{report}
%
% \cite{einstein}
% \citet{key}               Jones et al. (1990)
% \citet*{key}              Jones, Baker, and Smith (1990)
% \citep{key}               (Jones et al. 1990)
% \citep*{key}              (Jones, Baker, and Smith 1990)
% \citep[p.~99]{key}        (Jones et al., 1990, p. 99)
% \citep[e.g.][]{key}       (e.g. Jones et al., 1990)
% \citep[e.g.][p.~99]{key}  (e.g. Jones et al., 1990, p. 99)
% \citeauthor{key}          Jones et al.
% \citeauthor*{key}         Jones, Baker, and Smith
% \citeyear{key}            1990
\end{document}
