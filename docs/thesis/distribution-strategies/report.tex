
\documentclass[12pt, a4paper]{article}

\input{preamble}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{TODO}
\lhead{TODO}
\rfoot{Page \thepage}

\title{%
  \vspace{-10ex}
  Maximal Matches Disjoint Enumeration
}
\author{%
  Arnau Abella \\
  \large{Universitat Polit\`ecnica de Catalunya}
}
\date{\today}

\begin{document}
\maketitle
% \tableofcontents

%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}

On one hand, CORE's evaluation algorithm guarantees \textit{output-linear} delay enumeration of the output \cite{core}.
Although each enumeration can be accomplished in linear time with respect to the size of the complex event,
the cost of enumerating all complex events from a CEQL that contains an iteration clause is exponential \textit{w.r.t} the size of this clause \cite{grez_et_al:LIPIcs:2019:10307}.

Selection strategies (\textit{STRICT}, \textit{NXT}, \textit{LAST}, \textit{MAX}) were created to restrict the size of the output set.
In the case of CORE, this bounds the execution time of the enumeration process.
However, all four selection strategies still suffer exponential growth complexity in the presence of iterations.

\section{Algorithm}
\label{sec:algorithm}

In order to deal with the exponential complexity of enumerating all submatches of a query that contains multiple iteration patterns, we propose the distributed enumeration algorithm \gls{mmde}.

The algorithms presented in \textit{CORE: a COmplex event Recognition Engine} are based on the well-founded complex event semantics $\llbracket \varphi \rrbracket (S) := \{ C_{V} \ | \ V \in \llceil \varphi \rrfloor (S) \}$. But, the algorithms of this section are based on the definition of match (\ref{def:match}) and maximal match (\ref{def:maximalmatch}) which are both data structures produced by CORE (the engine).

\begin{definition}[Match]
  \label{def:match}
  TODO
\end{definition}

\begin{definition}[Maximal Match]
  \label{def:maximalmatch}
  TODO
\end{definition}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoLine
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{MMDE}{MaximalMatchesDisjointEnumeration}
  \SetKwFunction{Enumerate}{Enumerate}

  \Procedure{\MMDE{$M$}}{
    % 1. For all maximal matches:
    %     1.1. Group by event type: {{A1}, {B1 B2}, {C1 C2 C3}, {D1}}
    %     1.2. Subsets sizes: {{1}, {1,2}, {1,2,3}, {1}}
    %     1.3. Cartesian product of subsets sizes to generate all configurations:
    %     1.4. Match configurations and their corresponding maximal matches.
    % 2. Distribute all tuples <maximal matches, configuration> using a load-balancing algorithm.

    \For{$m_{i} \in M$}{
    }
  }
  \;
  \Procedure{\Enumerate{$foo$}}{
    $location \gets 0$\;
    $i \gets 2$\;
    \While{$i \leq n$ \textbf{and} $location = 0$}{
      $j \gets 1$\;
      \While{$j < i$ \textbf{and} $location = 0$}{
        \uIf{$a_i = a_j$}{
          $location \gets i$\;
        }
        \Else{
          $j \gets j + 1$\;
        }
      }
      $i \gets i + 1$\;
    }
  }
  \;
  % \Return{location}\;
\caption{\glsentrylong{mmde}}
\label{algo:mmde}
\end{algorithm}

\subsection{Proof}
\label{subsec:proof}

You need to make the following observations of "Maximal Matches Enumeration":
1. The algorithm produces disjoint submatches given a maximal match.
2. The algorithm produces non-disjoint submatches given multiple maximal matches.

But (2) can be analyzed further:
1. Disjoint configurations produce disjoint submatches.
2. Non-disjoint configurations produce non-disjoint submatches.

From previous observations we can conclude that repeated submatches are only generated by applying the same configuration to different maximal matches.

We propose the following algorithm:
1. (1.1),(1.2),(1.3) and (1.4) as in "Maximal Matches Enumeration"
2. Group pairs from (1) by configuration: <configuration, {maximal matches}>
3. Distribute pairs from (2). Each configuration is assigned to a single worker.
4. Enumerate submatches at worker. The output must be a set since enumeration may generated repeated outputs.

Uniqueness of submatches is guaranteed by (3) and (4).
(3) guarantees that the output of each worker is disjoint wrt the others.
(4) guarantees that the output of a worker is disjoint.

The complexity of the algorithm remains the same if we accomplish linear time enumeration in each worker (this is the tricky part).

\begin{lemma}[TODO]
  \label{lemma:todo}
  TODO
\end{lemma}

\begin{theorem}[TODO]
  \label{theorem:todo}
  TODO
\end{theorem}

\begin{example}[TODO]
  \label{example:todo}
  TODO
\end{example}

%%%%%%%%%%%%%% BIBLIOGRAPHY %%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrv}
\bibliography{report}
%
% \cite{einstein}
% \citet{key}               Jones et al. (1990)
% \citet*{key}              Jones, Baker, and Smith (1990)
% \citep{key}               (Jones et al. 1990)
% \citep*{key}              (Jones, Baker, and Smith 1990)
% \citep[p.~99]{key}        (Jones et al., 1990, p. 99)
% \citep[e.g.][]{key}       (e.g. Jones et al., 1990)
% \citep[e.g.][p.~99]{key}  (e.g. Jones et al., 1990, p. 99)
% \citeauthor{key}          Jones et al.
% \citeauthor*{key}         Jones, Baker, and Smith
% \citeyear{key}            1990
\end{document}
