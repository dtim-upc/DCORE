\subsection{Distributed tECS enumeration}
\label{subsec:label}

% Recall that this algorithm does not work since permutations is already exponential and you gain nothing.
% There is still the algorithm proposed to Sergi but there are still some open questions (see 'Sent Mail')

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Distribute}{\textsc{Distribute}}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}

  \Procedure{\Distribute{$\mathcal{E}, n, \epsilon, j, P, W$}}{
     \nl $b <- bitstring(|P|)$\;
     \nl $B <- permutations(b)$\;
     $\mathcal{G} \leftarrow \emptyset$\;
     \ForEach{$b \in B$}{
       $G = \emptyset$\tcp*[l]{$f: N_{U} \rightarrow \{ \bot , \top \}$}
       \For{$i \leftarrow 1$ \KwTo $|p|$}{
           $G \leftarrow G \cup (P_{i}, b_{i})$\;\label{algo:de:7}
       }
       $\mathcal{G} \leftarrow \mathcal{G} \cup G$\;
     }
     $S \leftarrow \emptyset$\tcp*[l]{Assignments}\label{algo:de:9}
     \For{$i \leftarrow 1$ \KwTo $|\mathcal{G}|$}{
       \nllabel{2}$i' \leftarrow i \mod |W|$\;
       $S \leftarrow S \cup (S_{i'} \cup \{ \mathcal{G}_{i} \} )$\;
     }\label{algo:de:12}
     \For{$i \leftarrow 1$ \KwTo $|W|$}{
        $W_{i}.\textsc{Enumerate}(\mathcal{E}, n, \epsilon, j, S_{i})$\;
     }
  }
\caption{Distributed enumeration of $\llbracket n \rrbracket^{\epsilon}_{\mathcal{E}}(j)$}
\label{algo:de}
\end{algorithm}

\setlength{\interspacetitleruled}{-.4pt}%
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNotNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \nl \Procedure{\Enumerate{$\mathcal{E}, n, \epsilon, j, \mathcal{G}$}}{
    $\cdots$\;
    \setcounter{AlgoLine}{13}
    \nl \ElseIf{$n' \in N_{U}$}{
      \nl$choice \leftarrow (\bot, \bot)$\tcp*[l]{(left, right)}
      \nl\ForEach{$G \in \mathcal{G}$}{\label{algo:enumerate:16}
        \nl\If{$G_{1}(u)$}{
          \nl$choice.right = \top$\;
        }
        \nl\Else{
          \nl$choice.left = \top$\;
        }
        \nl$G \leftarrow G \setminus \{ G_{i} \}$\;\label{algo:enumerate:21}
      }
      \nl\If{$choice.right \land max(right(n')) \geq \tau$}{\label{algo:enumerate:22}
        \nl$push(st, (right(n'), P))$\;
      }
      \nl\ElseIf{$choice.left$}{\label{algo:enumerate:24}
        \nl$n' \leftarrow left(n')$\;
      }
    }
    $\cdots$\;
  }
\label{algo:enumerate}
\end{algorithm}

We present Algorithm \ref{algo:de} which distributes the workload of \textsc{Enumerate} (Algorithm 1) from \cite{core} among $N$ workers. In order to incrementally distribute the enumeration of $\mathcal{E}$, we need to manipulate an additional ordered set $P$ of union nodes during the evaluation of \textsc{Evaluation}. This set will store all unions nodes present in $\mathcal{E}$ during the evaluation of the \gls{cea}. The algorithm consist of two distinct procedures: \textsc{Distribute} and \textsc{Enumerate}. \textsc{Distribute} replaces \textsc{Enumerate} in the original algorithm and \textsc{Enumerate} is executed remotely on each worker.

In detail, Algorithm \ref{algo:de} receives as an input a gls{tecs} $\mathcal{E}$, a node $n$, a time-window bound $\epsilon$, a position $j$, an ordered set of union nodes $P$ and, a set of workers $W$. First, creates a bitstring (e.g. $111111$) of size $|p|$ where each position corresponds to a union node in $\mathcal{E}$ and computes the $2^{n}$ permutations of this bitstring i.e. all possible paths that traverses the \gls{dag} $G_{\mathcal{E}}$ encoded by $\mathcal{E}$. Then, for each possible path, line \ref{algo:de:7} computes the mapping between the union node $P_{i}$ and the choice $b_{i}$ ($\top \equiv \text{ right}$ and $\bot \equiv \text{ left}$). Then, lines \ref{algo:de:9}-\ref{algo:de:12} distribute the paths among all workers. We chose the simples load-balancing algorithm, the round-robin but these lines can be replaced by any load-balancing algorithm. Finally, we call \textsc{Enumerate} on each worker using a \gls{rmi}.

On the other side of the cluster, each worker will be waiting for the remote call \textsc{Enumerate}. \textsc{Enumerate} is a modification of the algorithm \textsc{Enumerate} (Algorithm 2) from \cite{core}. The procedure receives a set $\mathcal{G}$ of binary relations $G$ that are the choices to be made on each union node. Notice, the traversing of the \gls{dag} can be done in a single traversal if we combine all the path choices at each union node (lines \ref{algo:enumerate:16}-\ref{algo:enumerate:21}). Then lines \ref{algo:enumerate:22} and \ref{algo:enumerate:24} have been modified to accommodate this choice.

(we need to prove this, it should be easy) Algorithm \ref{algo:de} still enumerates the set ${\llbracket n \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ in output-liner delay and without repetitions.

% CEA AB+
\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{streamAB+}
  \end{subfigure}
  \\
  \begin{subfigure}[b]{\textwidth}
    \begin{minted}[xleftmargin=40pt, linenos=false]{text}
      SELECT *
      FROM S
      WHERE A as a; B + as bb
    \end{minted}
  \end{subfigure}
  \\
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{ceaAB+}
  \end{subfigure}
  \caption{A CEA representing $Q_{1}$ from Figure 1 and some of its runs on an example stream.}
  \label{fig:label}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.1\linewidth}
    \inputtikz{AB+_0}
  \end{subfigure}
  \begin{subfigure}[t]{0.1\linewidth}
    \inputtikz{AB+_1}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_2}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_3}
  \end{subfigure}
  \begin{subfigure}[t]{0.28\linewidth}
    \inputtikz{AB+_4}
  \end{subfigure}
  \caption{Illustration of Algorithm 1 on the CEA $\mathcal{A}$ and stream $S$ of Figure ???.}
  \label{fig:label}
\end{figure}

% CEA A+B+
\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{streamA+B+}
  \end{subfigure}
  \\
  \begin{subfigure}[b]{\textwidth}
    \begin{minted}[xleftmargin=40pt, linenos=false]{text}
      SELECT *
      FROM S
      WHERE A + as aa; B + as bb
    \end{minted}
  \end{subfigure}
  \\
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{ceaA+B+}
  \end{subfigure}
  \caption{A CEA representing $Q_{1}$ from Figure 1 and some of its runs on an example stream.}
  \label{fig:label}
\end{figure}

\begin{figure}[H]
  \begin{subfigure}[t]{0.1\linewidth}
    \inputtikz{A+B+_0}
  \end{subfigure}
  \begin{subfigure}[t]{0.1\linewidth}
    \inputtikz{A+B+_1}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{A+B+_2}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{A+B+_3}
  \end{subfigure}
  \begin{subfigure}[t]{0.28\linewidth}
    \inputtikz{A+B+_4}
  \end{subfigure}
  \caption{Illustration of Algorithm 1 on the CEA $\mathcal{A}$ and stream $S$ of Figure ???.}
  \label{fig:label}
\end{figure}
