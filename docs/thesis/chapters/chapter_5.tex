\chapter{Distributed Evaluation of Second-Order Predicates}\label{chapter:}

In this section, we present two distributed enumeration algorithms: (1) \acrfull{mmde}, and (2) \acrfull{dte}.

CORE's evaluation algorithm guarantees, under data complexity, constant time per event and constant-delay enumeration of the output. However, under the default \emph{skip-till-any-match} \cite{skip-till-any-match} policy in CORE, non-contiguous sequencing and iteration can cause the amount of complex events to grow exponentially in the size of the stream \cite{formal-framework-cer}. The evaluation algorithms needs to materialize the set of partial matches each time an enumeration is required; therefore, in the worst case, enumerating all complex events generated by an event is exponential in the length of the stream. In order to deal with the exponential complexity of materializing and enumerating complex events in the evaluation algorithm, we propose to employ distributed execution of the process \cite{distributed-computing-book}.

% \subsection{Maximal Matches Disjoint Enumeration}\label{subsec:mmde}

We propose a novel enumeration algorithm called \acrfull{mmde}

Talk about the algorithm: build on top of CORE, in the compilation of the query,...

Define: match, maximal match, configuration, ... (get inspire by CORE's paper)

Define the operations on the tree.

Define group by (maybe, it would be easier to define a new concept)

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{MMDE}{\textsc{MaximalMatchesDisjointEnumeration}}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}

  \Procedure{\MMDE{$M$, $W$}}{
    \KwIn{A set of maximal matches $M := \{M_{1}, \ldots, M_{n}\}$ \newline
      and a set of workers $W := \{w_{1},\ldots, w_{m}\}$.
    }
    \KwResult{Enumerates all \emph{submatches} $\subseteq M$ without repetitions.}
    $C \leftarrow \emptyset$\;
    \ForEach{$M_{i} \in M$}{
        $C \leftarrow C \cup \textsc{Configurations}(M_{i}).map(\lambda c \to ( c, M_{i} ))$\;
    }
    $D \leftarrow C.groupBy(\lambda (c, \_ ) \to c)$\;
    $\textsc{Distribute}(W, D)$
  }
  \;
\caption{Non-repeated enumeration of a set of maximal matches.}
\label{algo:mmde}
\end{algorithm}

% This procedure enumerates all submatches of M without repetitions.
% It stills enumerates all submatches but only outputs non-repeated.
% It efficiently detects repetitions by constructing an n-ary tree of complex events.
% The complexity is still exponential w.r.t. the size of the largest iteration.
% The exponential time enumeration must be repeated a constant factor of times.
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \SetKwFunction{Enumeratee}{\textsc{Enumerate'}}

  \Procedure{\Enumerate{}}{
    \KwData{A set of tuples $A = \{ (c, \{ M_{1}, \ldots, M_{n}\}) \}$ where $c$ is a \emph{configuration} and $M_{i}$ are maximal matches.}
    \KwOut{The set of all submatches without repetitions.}
    \ForEach{$(c, M) \in A$}{
      $T \leftarrow$ \text{new-root()}
      \ForEach{$M_{i} \in M$}{
        $G \leftarrow \textsc{GroupBy}(M_{i})$\;
        $\textsc{Enumerate'}(T, G, \emptyset, \bot)$\;
        }
    }
  }
  \;
  \Procedure{\Enumeratee{$n, G, S, new$}}{
    \KwData{A node $n$, a set of grouped events $G$, a time-ordered set of events $S$, and a boolean $new$.}
    \Switch{$G$}{
      \uCase{$\emptyset$}{
        \If{$new$}{
          \Return{$S$}
        }
      }
      \uCase{$g \cup G'$}{
        $k \leftarrow c(g.type)$
        $E \leftarrow \binom{g}{k}$
        \ForEach{$e \in E$}{
          \eIf{$\exists n' \in n.children \land n'.event = e$}{
            $\textsc{Enumerate'}(n', G', S \cup e, new)$\;
          }{
            $p \leftarrow$ new-node($e$)\;
            $n.children.add(p)$\;
            \textsc{Enumerate'}$(p, G', S \cup e, \top)$\;
          }
        }
      }
    }
  }
  \;
\caption{Non-repeated enumeration of a set of maximal matches given a predicate configuration.}
\label{algo:enumerate}
\end{algorithm}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Configurations}{\textsc{Configurations}}

  \Procedure{\Configurations{$M$}}{
    \KwIn{A match $M = \{e_{1}, \ldots, e_{n}\}$ where $e_{i}$ is an event of type $t \in T$.}
    \KwOut{A set $C$ of configurations $c := T \times \mathbb{N}$ where $c$ is the mapping from the event type $t \in T$ to the size of the iteration of the event type $t$ in the submatches of $M$.}
    $V \leftarrow newList$\;
    $e_{0} \cup M' \leftarrow pop(M)$\;
    $A \leftarrow \{ e_{0} \}$\;
    $A.type \leftarrow e_{0}.type$\;
    \For{event $e$ in $M'$}{
      \eIf{$e.type = A.type$}{
        $A \leftarrow A \cup e$\;
        \uIf{$isLast(e)$} {
          $V \leftarrow V + enumFromTo(1, |A|)$
        }
      }{
        $V \leftarrow V + enumFromTo(1, |A|)$\;
        $A \leftarrow \{ e \}$\;
        $A.type \leftarrow e.type$\;
      }
    }
    $WW \leftarrow V_{1} \times \cdots \times V_{n}$\tcp*[l]{$V = \{V_{1}, \cdots, V_{n}\}$}
    $T \leftarrow types(M)$\tcp*[l]{Ordered set of types e.g. $types(A_{1}A_{2}B_{1}C_{1}) = \{A,B,C\}$}
    $C \leftarrow \emptyset$\;
    \ForEach(\tcp*[h]{E.g. $W = \{1, 2, 1\}$}){$W \in WW$}{
      $c \leftarrow \emptyset$\tcp*[l]{E.g. $c = \{(A,1), (B,2), (C, 1)\}$}
      \For{$i \leftarrow 1$ \KwTo $|W|$}{
        $c \leftarrow c \cup (T[i], W[i])$\;
      }
      $C \leftarrow C \cup c$\;
    }
    \Return{C}
  }
\caption{Computes all disjoint configurations of a maximal match.}
\label{algo:configurations}
\end{algorithm}

% You need to make the following observations of "Maximal Matches Enumeration":
% 1. The algorithm produces disjoint submatches given a maximal match.
% 2. The algorithm produces non-disjoint submatches given multiple maximal matches.

% But (2) can be analyzed further:
% 1. Disjoint configurations produce disjoint submatches.
% 2. Non-disjoint configurations produce non-disjoint submatches.

% From previous observations we can conclude that repeated submatches are only generated by applying the same configuration to different maximal matches.

% Uniqueness of submatches is guaranteed by (3) and (4).
% (3) guarantees that the output of each worker is disjoint wrt the others.
% (4) guarantees that the output of a worker is disjoint.

% The complexity of the algorithm remains the same if we accomplish linear time enumeration in each worker (this is the tricky part).

\begin{lemma}[TODO]
  \label{lemma:todo}
  TODO
\end{lemma}

\begin{theorem}[TODO]
  \label{theorem:todo}
  TODO
\end{theorem}

\begin{example}[TODO]
  \label{example:todo}
  TODO
\end{example}

% Soundness and Completness of an Algorithm
%
% Let S be the set of all right answers.
% A sound algorithm never includes a wrong answer in S, but it might miss a few right answers.
% A complete algorithm should get every right answer in S: include the complete set of right answers. But it might include a few wrong answers.
%
% Careful! Soudness and completness in logic has another meaning https://math.stackexchange.com/questions/105575/what-is-the-difference-between-completeness-and-soundness-in-first-order-logic

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

























\section{Chapter summary}
