\chapter{Distributed CER}\label{chapter:distributed-cer}

In this chapter we propose a novel framework for distributed CER that is based on CEL and CEA from Chapter~\ref{chapter:preliminaries}. We describe a first implementation based on this framework. Furthermore, we introduce several distributions strategies to be used on this implementation. Finally, we introduce an alternative implementation based on the distributed evaluation algorithm from Chapter~\ref{chapter:algorithm}. We show in Chapter~\ref{chapter:experimental_evaluation} that the latter implementation performance is overall better thanks to its ad-hoc evaluation algorithm.

\section{Proposed approach}\label{sec:proposed-approach}

Given the efficient evaluation of CEA in a centralized manner \cite{formal-framework-cer, core}, it is hard to foresee scenarios where it can benefit from distribution. Indeed, both automata distribution approaches (i.e., query partitioning and pipelining) will incur a big overhead in terms of network communication during the evaluation process to synchronize the tECS $\mathcal{E}$ and the enumeration process. However, as previously discussed, CEA is very limited in terms of filtering capabilities, allowing only \emph{unary} predicates. Thus, one might wonder how to include the evaluation of more complex filters over non-unary predicates such as binary predicates (e.g., an equi-join \code{h1[id] = t2[id]}), or second-order predicates (e.g., the sequence of \code{T[val]} must monotonically increase). In \cite{on-the-expressiveness}, it is discussed that CEL and CEA are equivalent in expressive power when CEL is restricted to unary predicates, but incomparable in general. Thus, non-unary CEL, in general, cannot be compiled into an equivalent CEA. However, one could split the pattern matching process and the filtering in CER. In other words, we would maintain the generation of complex events in CEA, but leverage on a distributed framework for complex filtering.

We propose a framework for distributed complex event recognition based on the previous discussion. The framework receives a stream of data-tuples and a query as an input. We will use CEQL as our query language, but we will allow $n$-ary CEL predicates inside the \code{WHERE} clause. The query is parsed using any context free grammar (CFG) parsing algorithm (e.g., Earley's algorithm \cite{earley}). The resulting abstract syntax tree (AST) is applied to the \emph{rewrite algorithm}. The rewrite algorithm translates the non-unary CEL predicate into a unary CEL predicate of a CEQL query, and outputs the corresponding non-unary predicates as a compact AST for later use, if any. The resulting CEQL query is compiled into a CEA by \cite[Theorem~6.2]{formal-framework-cer}. Then, this CEA and the input stream are evaluated using one the efficient evaluation algorithms presented in \cite{formal-framework-cer, core}. Notice, the results of this evaluation is not yet a valid output since we still need to apply the \code{FILTER} clause for the non-unary predicates, if present. The resulting set of complex events is distributed among the processing units of the distributed system using any of the \emph{distribution strategies} (explained below). Then, each processing unit applies the \emph{refine algorithm} to its assigned complex events. The refine algorithm uses the non-unary predicates to filter the complex events. Finally, each processing unit outputs the set of complex events corresponding to the input query.

\textbf{Note}. We implemented a rewrite and refine algorithm that only works for very specific queries. Implementing a generic rewrite and refine algorithm is outside of the scope of this thesis and it is left for future work.

\section{Prototype I}\label{sec:prototype:I}

In this section, we discuss an implementation of the framework proposed in Section~\ref{sec:proposed-approach}. This implementation is built on top of a distributed actor model (see Chapter~\ref{chapter:implementation} for more details). We will differentiate between two types of actors: master and slave. There will be a single master actor in the cluster, and as many slave actors as processing units left. The master actor will act as the leader of the cluster and will orchestrate the rest of the slave actors. The master actor receives a stream of data-tuples and a query as an input. It parses and rewrite the input query to unary CEL. Then, it compiles the query to CEA, and evaluate it to retrieve the corresponding set of complex events. For this implementation we use the evaluation algorithm from \cite{formal-framework-cer} which guarantees constant update of the data structure and output-linear delay enumeration. Then, we apply one of the selection strategies from Section~\ref{subsec:distribution-strategies} to distribute the set of complex events among the slave actors. Asynchronously and independently, each processing unit receives its corresponding subset of complex events and it applies the refine algorithm to the complex events. Afterwards, once the refine algorithm is finished, the actor returns the resulting subset of complex events to the master node. Finally, once the master has received the output of all processing units, it executes the configured response (e.g., write the complex events to disk, or send an email, or activate an alarm \ldots).

\subsection{Distribution Strategies}\label{subsec:distribution-strategies}

In this section we describe the distributions strategies used by Prototype~I to distribute the set of complex events among the set of actors on the distributed system. We have considered distribution strategies ranging from \emph{load-balancing algorithms} to \emph{stream partitioning algorithms}. But, we have also proposed our own novel distribution strategies specific to the distribution of complex events.

We briefly describe existing distribution strategies and refer the interested reader to its original publication for further information. The newly presented distribution strategies are extensively described. We compare the proposed selection strategies in Chapter~\ref{chapter:experimental_evaluation}.

\textbf{Shuffling}.

\textbf{Weighted Shuffling}.

\textbf{Power of Two Choices}. The \emph{Power of Two Choices (PoTC)} \cite{load-balancing-1} is a randomized load balancing ...

\textbf{Maximal Matches Enumeration}.

\textbf{Maximal Matches Disjoint Enumeration}.

\subsubsection{Maximal Matches Disjoint Enumeration}\label{subsubsec:mmde}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{MMDE}{\textsc{MaximalMatchesDisjointEnumeration}}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}

  \Procedure{\MMDE{$M$, $W$}}{
    \KwIn{A set of maximal matches $M := \{M_{1}, \ldots, M_{n}\}$ \newline
      and a set of workers $W := \{w_{1},\ldots, w_{m}\}$.
    }
    \KwResult{Enumerates all \emph{submatches} $\subseteq M$ without repetitions.}
    $C \leftarrow \emptyset$\;
    \ForEach{$M_{i} \in M$}{
        $C \leftarrow C \cup \textsc{Configurations}(M_{i}).map(\lambda c \to ( c, M_{i} ))$\;
    }
    $D \leftarrow C.groupBy(\lambda (c, \_ ) \to c)$\;
    $\textsc{Distribute}(W, D)$
  }
  \;
\caption{Non-repeated enumeration of a set of maximal matches.}
\label{algo:mmde}
\end{algorithm}

% This procedure enumerates all submatches of M without repetitions.
% It stills enumerates all submatches but only outputs non-repeated.
% It efficiently detects repetitions by constructing an n-ary tree of complex events.
% The complexity is still exponential w.r.t. the size of the largest iteration.
% The exponential time enumeration must be repeated a constant factor of times.
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \SetKwFunction{Enumeratee}{\textsc{Enumerate'}}

  \Procedure{\Enumerate{}}{
    \KwData{A set of tuples $A = \{ (c, \{ M_{1}, \ldots, M_{n}\}) \}$ where $c$ is a \emph{configuration} and $M_{i}$ are maximal matches.}
    \KwOut{The set of all submatches without repetitions.}
    \ForEach{$(c, M) \in A$}{
      $T \leftarrow$ \text{new-root()}
      \ForEach{$M_{i} \in M$}{
        $G \leftarrow \textsc{GroupBy}(M_{i})$\;
        $\textsc{Enumerate'}(T, G, \emptyset, \bot)$\;
        }
    }
  }
  \;
  \Procedure{\Enumeratee{$n, G, S, new$}}{
    \KwData{A node $n$, a set of grouped events $G$, a time-ordered set of events $S$, and a boolean $new$.}
    \Switch{$G$}{
      \uCase{$\emptyset$}{
        \If{$new$}{
          \Return{$S$}
        }
      }
      \uCase{$g \cup G'$}{
        $k \leftarrow c(g.type)$
        $E \leftarrow \binom{g}{k}$
        \ForEach{$e \in E$}{
          \eIf{$\exists n' \in n.children \land n'.event = e$}{
            $\textsc{Enumerate'}(n', G', S \cup e, new)$\;
          }{
            $p \leftarrow$ new-node($e$)\;
            $n.children.add(p)$\;
            \textsc{Enumerate'}$(p, G', S \cup e, \top)$\;
          }
        }
      }
    }
  }
  \;
\caption{Non-repeated enumeration of a set of maximal matches given a predicate configuration.}
\label{algo:enumerate}
\end{algorithm}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Configurations}{\textsc{Configurations}}

  \Procedure{\Configurations{$M$}}{
    \KwIn{A match $M = \{e_{1}, \ldots, e_{n}\}$ where $e_{i}$ is an event of type $t \in T$.}
    \KwOut{A set $C$ of configurations $c := T \times \mathbb{N}$ where $c$ is the mapping from the event type $t \in T$ to the size of the iteration of the event type $t$ in the submatches of $M$.}
    $V \leftarrow newList$\;
    $e_{0} \cup M' \leftarrow pop(M)$\;
    $A \leftarrow \{ e_{0} \}$\;
    $A.type \leftarrow e_{0}.type$\;
    \For{event $e$ in $M'$}{
      \eIf{$e.type = A.type$}{
        $A \leftarrow A \cup e$\;
        \uIf{$isLast(e)$} {
          $V \leftarrow V + enumFromTo(1, |A|)$
        }
      }{
        $V \leftarrow V + enumFromTo(1, |A|)$\;
        $A \leftarrow \{ e \}$\;
        $A.type \leftarrow e.type$\;
      }
    }
    $WW \leftarrow V_{1} \times \cdots \times V_{n}$\tcp*[l]{$V = \{V_{1}, \cdots, V_{n}\}$}
    $T \leftarrow types(M)$\tcp*[l]{Ordered set of types e.g. $types(A_{1}A_{2}B_{1}C_{1}) = \{A,B,C\}$}
    $C \leftarrow \emptyset$\;
    \ForEach(\tcp*[h]{E.g. $W = \{1, 2, 1\}$}){$W \in WW$}{
      $c \leftarrow \emptyset$\tcp*[l]{E.g. $c = \{(A,1), (B,2), (C, 1)\}$}
      \For{$i \leftarrow 1$ \KwTo $|W|$}{
        $c \leftarrow c \cup (T[i], W[i])$\;
      }
      $C \leftarrow C \cup c$\;
    }
    \Return{C}
  }
\caption{Computes all disjoint configurations of a maximal match.}
\label{algo:configurations}
\end{algorithm}

% You need to make the following observations of "Maximal Matches Enumeration":
% 1. The algorithm produces disjoint submatches given a maximal match.
% 2. The algorithm produces non-disjoint submatches given multiple maximal matches.

% But (2) can be analyzed further:
% 1. Disjoint configurations produce disjoint submatches.
% 2. Non-disjoint configurations produce non-disjoint submatches.

% From previous observations we can conclude that repeated submatches are only generated by applying the same configuration to different maximal matches.

% Uniqueness of submatches is guaranteed by (3) and (4).
% (3) guarantees that the output of each worker is disjoint wrt the others.
% (4) guarantees that the output of a worker is disjoint.

% The complexity of the algorithm remains the same if we accomplish linear time enumeration in each worker (this is the tricky part).


\section{Prototype II}\label{sec:prototype:II}









\section{Chapter summary}

TODO
