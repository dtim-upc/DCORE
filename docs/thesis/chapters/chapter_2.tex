\chapter{Related Work}\label{chapter:related_work}

CER systems are usually divided into three categories:  automata-based, tree-based, and logic-based, with some systems (e.g. \cite{esper, tesla}) being hybrids. We situate our work among the three approaches, and refer the reader to recent surveys \cite{survey-systems-1,survey-systems-2,research-evaluation-query} for an in-depth discussion of these classes of systems.

\textbf{Automata-based systems}. \emph{Automata-based systems} typically propose a CER query language that is inspired by regular expressions which are evaluated by custom automata models. Our work has been inspired by CORE \cite{core}, and falls in the class of automata-based systems. Previous proposals (like SASE \cite{sase}) do not provide \emph{denotational semantics} for their language. As a result, either iterations cannot be nested \cite{skip-till-any-match}, or their semantics is confusing \cite{next-cep}. Other proposals (like TESLA \cite{tesla}) have formal semantics, but they do not include the iteration operator. An exception is Cayuga \cite{cayuga},  but their sequencing operator is non-associative, which results in confusing semantics. CORE \cite{core} is the first framework that provides a well-defined formal semantics that is compositional, allowing arbitrary nesting of operators. Moreover, it is the first evaluation algorithm that guarantees, under data complexity, constant time per event and output-linear delay enumeration.

\textbf{Tree-based systems}. \emph{Tree-based systems} \cite{esper, tree-based-system-1, tree-based-system-2} typically consider a CER query language that is inspired by a regular expression. Unlike automata-based system, the queries are evaluated by constructing and evaluating a tree of CER operators. Again, the semantics of queries is not formally defined. Moreover, the evaluation trees do not have formal performance guarantees, even for regular CER queries.

\textbf{Logic-based systems}. \emph{Logic-based systems} \cite{logic-based-system-1, logic-based-system-2, logic-based-system-3} typically express CER queries as rules in some form of logic, e.g., \emph{temporal logic} or \emph{event calculus}, and consequently evaluate CER as logical inference. Consequently, logic-based systems have formal semantics. However, iteration is often expressed by means of recursive rules instead of as an individual operator. Such rule can detect that a CER pattern applies repeatedly, but they do not typically capture the participating events as part of the complex event. Then, the semantics of iteration in logic-based system is different from CEQL.

\textbf{CORE}. CORE \cite{core} is the first CER engine that circumvents the super-linear partial match problem. It is the first system to propose a representation of partial matches with formal, proven, and optimal performance guarantees. It uses the query language CEQL that has well-defined formal semantics \cite{on-the-expressiveness}. One limitation is that the evaluation algorithm is sequential. Another limitation is that it is restricted to the language unary CEQL, which is less expressive than CEQL \cite{on-the-expressiveness}.

\textbf{Distributed CER}. \emph{Distributed CER systems} typically propose to increase the throughput by distributing the workload into a cluster of machines. Several distributed CER systems have been previously proposed \cite{esper, flink-cep, next-cep, distributed-related-work-1, distributed-related-work-2}, however, they do not usually have a well-defined computational model with clear performance guarantees \cite{distributed-related-work-1}, and they do usually suffer from communication overhead and require complex heuristics to optimize performance \cite{distributed-related-work-2}

\textbf{Load-balancing}. \emph{Load-balancing} typically involves distributing a set of tasks over a set of resources (computing units), with the aim of making their overall processing more efficient. Load-balancing has been thoroughly studied \cite{load-balancing-1, load-balancing-2, load-balancing-3} in distinct fields of computer science (e.g., streaming processing, task scheduling, among others). However, as far as we are concerned, load-balancing has not been particularly studied when the tasks to distribute are complex events.
