\chapter{Distributed COmplex event Recognition Engine}\label{chapter:algorithm}

% Here we should start by CORE 5.Evaluation algorithm

% TODO this is old, rewrite.
In this section, we propose \acrfull{dte}, a novel extension of the evaluation algorithm in \cite{core}. In particular, \acrshort{dte} distributes the potentially exponential workload of \textsc{Enumerate} among $n$ asynchronous processes $p_{1}, \ldots, p_{n}$ while preserving the constant time per input event update of the data structure that compactly represents the set of partial matches and the output-linear delay enumeration of the results.

Before giving the formal description of the algorithm, we need to extend the definition of \acrfull{tecs}, as introduced in \cite{core}. A \acrshort{tecs} is a \acrfull{dag} \tecs with two kinds of nodes; union nodes and non-union nodes. Every union node u has exactly two children, the left child left(u) and the right child right(u). Every non-union node n is labelled by a stream position (an element of $\mathcal{N}$) and has at most one child. If non-union node n has no child it is called a \emph{bottom node}, otherwise it is an \emph{output node}. We write pos(n) for the label of non-union node n and next(o) for the unique child of output node o. For a node n, define its \emph{descending-paths}, denoted paths(n), as follows: if n is a bottom node, then paths(n) = 1; if n is an output node, then paths(n) = paths(next(n)); otherwise, paths(n) = paths(left(n)) + paths(right(n)). The descending-paths can be computed in constant.

A \acrshort{tecs} represents sets of \emph{open} complex events. An \emph{open complex event} is a pair $(i, D)$ where $i \in \mathcal{N}$ and $D$ is a finite subset of $\{i, i+1, \ldots\}$. Intuitively, when processing a stream, the open complex events represented by a tECS are partial results that may later become full complex events. Remember that the purpose of constructing \tecs is to be able to enumerate the set \enumCEA at every $j$. To achieve that goal, it will be necessary to enumerate, for certain nodes n in \tecs, the set $\InDoubleBrackets{\text{n}}^{\epsilon}_{\mathcal{E}}(j) := \{ ([i, j], D) | (i, D) \in \InDoubleBrackets{\text{n}}_{\mathcal{E}} \land j - i \leq \epsilon \}$ i.e. all open complex events represented by n that, when closed with j, are within a time window of size $\epsilon$.

Recall that we imposed three restrictions on the structure of a \acrshort{tecs}: (1) it needs to be \emph{time-ordered}, (2) it needs to be \emph{k-bounded}, and (3) its needs to be \emph{duplicate-free}.

We defined three operations on \tecs: new-bottom($i$), extend(m, $j$) and union($\text{n}_{1},\text{n}_{2}$). The first method, new-bottom($i$) adds a new bottom node b labelled $i$ to \tecs. The second method, extend(n, $j$) adds a new output node o to \tecs with pos(o) = $j$ and next(o) = n. The third method, union($\text{n}_{1},\text{n}_{2}$) returns a node u such that $\InDoubleBrackets{u}_{\mathcal{E}} = \InDoubleBrackets{\text{n}_{1}}_{\mathcal{E}} \cup \InDoubleBrackets{\text{n}_{2}}_{\mathcal{E}}$. Any \acrshort{tecs} that is created using only these three methods is time-ordered and $3$-bounded.

% CEA AB+
\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{streamAB+}
  \end{subfigure}
  \\
  \begin{subfigure}[b]{\textwidth}
    \begin{minted}[xleftmargin=40pt, linenos=false]{text}
      SELECT *
      FROM S
      WHERE A as a; B + as bb
    \end{minted}
  \end{subfigure}
  \\
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{ceaAB+}
  \end{subfigure}
  \caption{A CEA representing $Q_{1}$ from Figure 1 and some of its runs on an example stream.}
  \label{fig:label}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.1\linewidth}
    \inputtikz{AB+_0}
  \end{subfigure}
  \begin{subfigure}[t]{0.1\linewidth}
    \inputtikz{AB+_1}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_2}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_3}
  \end{subfigure}
  \begin{subfigure}[t]{0.28\linewidth}
    \inputtikz{AB+_4}
  \end{subfigure}
  \caption{Illustration of Algorithm TODO on the CEA $\mathcal{A}$ and stream $S$ of Figure ???.}
  \label{fig:label}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_enumeration_0}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_enumeration_1}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_enumeration_2}
  \end{subfigure}
  \begin{subfigure}[t]{0.24\linewidth}
    \inputtikz{AB+_enumeration_3}
  \end{subfigure}
  \caption{Illustration of Algorithm \ref{algo:enumeration} on the CEA $\mathcal{A}$ and stream $S$ of Figure ???.}
  \label{fig:label}
\end{figure}

% CEA A+B+
% \begin{figure}[H]
%   \centering
%   \begin{subfigure}[t]{\textwidth}
%     \centering
%     \inputtikz{streamA+B+}
%   \end{subfigure}
%   \\
%   \begin{subfigure}[b]{\textwidth}
%     \begin{minted}[xleftmargin=40pt, linenos=false]{text}
%       SELECT *
%       FROM S
%       WHERE A + as aa; B + as bb
%     \end{minted}
%   \end{subfigure}
%   \\
%   \begin{subfigure}[b]{\textwidth}
%     \centering
%     \inputtikz{ceaA+B+}
%   \end{subfigure}
%   \caption{A CEA representing $Q_{1}$ from Figure 1 and some of its runs on an example stream.}
%   \label{fig:label}
% \end{figure}

% \begin{figure}[H]
%   \begin{subfigure}[t]{0.1\linewidth}
%     \inputtikz{A+B+_0}
%   \end{subfigure}
%   \begin{subfigure}[t]{0.1\linewidth}
%     \inputtikz{A+B+_1}
%   \end{subfigure}
%   \begin{subfigure}[t]{0.24\linewidth}
%     \inputtikz{A+B+_2}
%   \end{subfigure}
%   \begin{subfigure}[t]{0.24\linewidth}
%     \inputtikz{A+B+_3}
%   \end{subfigure}
%   \begin{subfigure}[t]{0.28\linewidth}
%     \inputtikz{A+B+_4}
%   \end{subfigure}
%   \caption{Illustration of Algorithm 1 on the CEA $\mathcal{A}$ and stream $S$ of Figure ???.}
%   \label{fig:label}
% \end{figure}


\section{The evaluation algorithm}\label{sec:evaluation}

% TODO this is old, rewrite.
We are ready to description algorithm \acrshort{dte}. An efficient implementation would be execute \cite[Algorithm 1]{core} on a single process e.g. $p_{0}$, and distribute the \acrshort{tecs} \tecs to the rest of the processes $p_{1}, \ldots, p_{n}$, so $p_{0}$ could keep ingesting events at constant time while the rest of processes could be working on the possibly exponential enumeration of \tecs. However, if done in a na\"ive way, distributing the \acrshort{tecs} on each event that triggers a complex event would take time proportional to its size which is at most linear in the length of the stream breaking the constant update time. Hence, the distribution of the tECS has to be done incrementally per input event to preserve the constant time complexity. An algorithm that that incrementally distributes the tECS would need to send to each process all new node added to the tECS at iteration $j$ and additional information on how to add these nodes to the tECS of iteration $j-1$. Furthermore, each process would need to keep an updated hash table, similar to the one used in the evaluation algorithm, in order to apply the incremental changes instructed by the messages from the centralized evaluation process. We argue that this incremental distribution algorithm is \emph{asymptotically equivalent} to executing the update phase from \cite[Algorithm 1]{core} on each process. Both algorithms needs to incrementally update the tECS and the hash table $T$ but the later needs to iterate over all transitions $\Delta$ in the worst-case, however, this takes constant time under data complexity. Consequently, we choose to replicate the update phase of Algorithm 1 on each process and leave for future work a more sophisticated approach.

\begin{algorithm}[H]
  \setstretch{0.9} % space between lines
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Evaluation}{\textsc{Evaluation}}
  \SetKwFunction{ExecTrans}{\textsc{ExecTrans}}
  \SetKwFunction{Add}{\textsc{Add}}
  \SetKwFunction{Output}{\textsc{Output}}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \SetKwFunction{Yield}{yield}
  \SetKwFunction{NewUlist}{new-ulist}
  \SetKwFunction{NewBottom}{new-bottom}
  \SetKwFunction{OrderedKeys}{ordered-keys}
  \SetKwFunction{Merge}{merge}
  \SetKwFunction{Extend}{extend}
  \SetKwFunction{Keys}{keys}
  \SetKwFunction{Insert}{insert}
  \Procedure{\Evaluation{$\mathcal{A}, S, \epsilon, p$}}{
    $j \leftarrow -1$\;
    $T \leftarrow \emptyset$\;
    \While{$t \leftarrow $ \Yield{$S$}}{
      $j \leftarrow j + 1$\;
      $T' \leftarrow \emptyset$\;
      $ul \leftarrow $\NewUlist{\NewBottom{$j$}}\;
      \ExecTrans{$q_{0}, ul, t, j$}\;
      \For{$p \in$ \OrderedKeys{$T$}}{
        \ExecTrans{$p, T[p], t, j$}\;
      }
      $T \leftarrow T'$\;
      \Output{$j, \epsilon, p$}\;
    }
  }
  \;
  \Procedure{\ExecTrans{$p, ul, t, j$}}{
    $n \leftarrow$ \Merge{$ul$}\;
    \If{$q \leftarrow \Delta(p, t, \bullet)$}{
      $n' \leftarrow$ \Extend{$n, j$}\;
      $ul' \leftarrow$ \NewUlist{$n'$}\;
      \Add{$q, n', ul'$}\;
    }
    \If{$q \leftarrow \Delta(p, t, \circ)$}{
      \Add{$q, n, ul$}\;
    }
  }
  \;
  \Procedure{\Add{$q, n, ul$}}{
    \eIf{$q \in$ \Keys{$T'$}}{
      $T'[q] \leftarrow$ \Insert{$T'[q], n$}\;
    }{
      $T'[q] \leftarrow ul$\;
    }
  }
  \;
  \Procedure{\Output{$j, \epsilon, p$}}{
    \For{$p \in$ \Keys{$T$}}{
      \If{$p \in F$}{
        $n \leftarrow$ \Merge{$T[p]$}\;
        \Enumerate{$n, j$}\;
      }
    }
  }
\caption{Evaluation of an I/O-deterministic \mbox{CEA ${\mathcal{A} = (Q, \Delta, q_{0}, F)}$} over a stream $S$ given a time-bound $\epsilon$ on a process $p$.}
\label{algo:update}
\end{algorithm}

% I am skipping proving Theorem 3 since it is more work added to the already endless amount of work to do.

\section{The enumeration algorithm}\label{sec:enumeration}

We provide \aref{algo:enumeration} and show that: (1) it enumerates a subset of ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ of size $\Omega(\frac{{\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j))}{|\mathcal{P}|})$, and (2) it does so with output-linear delay after the first complex event. Furthermore, we will show that (3) the union of the enumeration of \aref{algo:enumeration} on each process $p \in \mathcal{P}$ corresponds to ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$.

\begin{algorithm}[H]
  \setstretch{1.0} % space between lines
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \Procedure{\Enumerate{$\mathcal{E}, n, \epsilon, j, p$}}{
    $\delta \leftarrow \lceil \text{paths(n)} \ / \ {|\mathcal{P}|} \rceil$\;
    $\sigma \leftarrow \text{index}(p) \cdot \delta$\;
    st $\leftarrow$ new-stack()\;
    $\tau \leftarrow j - \epsilon $\;
    \If{$\text{max(n)} \ge \tau$}{
      push(st,($n$, $\emptyset$, $\sigma$, $\delta$))\;
    }
    \While{$(n', P, \sigma', \delta') \leftarrow$ pop(st)}{\label{line:enumeration:while:1}
      \While{true}{\label{line:enumeration:while:2}
        \If{$n' \in N_{B}$}{
          output([pos($n'$), $j$], $P$)\;\label{line:enumeration:output}
          \textbf{break}\;\label{line:enumeration:break}
        }
        \ElseIf{$\text{n}' \in N_{O}$}{
          $P \leftarrow P \ \cup $ {pos($n'$)}\;
          $n' \leftarrow $ next($n'$)\;
        }
        \ElseIf{$n' \in N_{U}$}{
          \If{$max(right(n')) \ge \tau$}{
            \eIf{$paths(left(n')) > \sigma'$}{
              $\delta'' \leftarrow \delta' - max(0, paths(left(n')) - \sigma')$\;
            }{
              $\delta'' \leftarrow \delta'$\;
            }
            $\sigma'' \leftarrow max(0, \sigma' - paths(left(n')))$\;
            \If{$paths(right(n')) > \sigma'' \land \delta'' > 0$}{\label{line:enumeration:if:1}
              push(st, (right($n'$), $P$, $\sigma''$, $\delta''$))\;
            }
          }
          \eIf{$paths(left(n')) > \sigma'$}{\label{line:enumeration:if:2}
            $n' \leftarrow left(n')$\;
          }{
            \textbf{break}\;
          }
        }
      }
    }
  }
\caption{Enumeration of ${paths}_{\ge \tau, \sigma, \delta}$.}
\label{algo:enumeration}
\end{algorithm}

\aref{algo:enumeration} uses a stack $st$ with common stack operations: \code{new-stack()} to create an empty stack, \code{push(st, e)} to add an element \code{e} at the top of the stack, and \code{pop(st)} to remove and return the element on the top of the stack. When the stack is empty, we will interpret $e \leftarrow pop(st)$ as \code{false}. We assume that stack operations can be performed in constant time.

Recall that $\mathcal{E}$ encodes the \acrshort{dag} $G_{\mathcal{E}} = (N, E)$ where $N$ are the vertices, and $E$ the edges that go from any union node $u$ to left($u$) and right($u$), and from any output node $o$ to next($o$). For every node $n' \in N$, let ${paths}_{\ge \tau}(n')$ be all paths of $G_{\mathcal{E}}$ that start at $n'$ and end at some bottom node $b$ with $pos(b) \ge \tau$ and let ${paths}_{\ge \tau, \sigma, \delta}(n')$ be a subset of ${paths}_{\ge \tau}(n')$ of size at most $\delta$ starting after path $\pi_{\sigma}$. It is clear that there exists a bijection between ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ and $paths_{\ge j - \epsilon}(n)$ i.e. for every complex event within a time window of size $\epsilon$ there exists exactly one path that reaches a bottom node $b$ with $pos(b) \ge j - \epsilon$, and vice versa. Formally,

\begin{theorem}[${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longleftrightarrow paths_{\ge j - \epsilon}(n)$]\label{theorem:bijection}
For every complex event within a time window of size $\epsilon$ there exists exactly one path that reaches a bottom node $b$ with $pos(b) \ge j - \epsilon$, and vice versa.
\end{theorem}

\begin{proof}
  Fix a node $n$ in $\mathcal{E}$. The proof follows by the definition of ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$, ${\llbracket \text{n} \rrbracket}_{\mathcal{E}}$, ${\llbracket \bar{p} \rrbracket}_{\mathcal{E}}$, and ${paths}_{\ge \tau}(n)$. Recall that

  \begin{itemize}
    \item ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) = \{ ([i,j], D) | (i,D) \in {\llbracket \text{n} \rrbracket}_{\mathcal{E}} \land j - i \le \epsilon \}$ encodes all open complex events represented by $n$ in $\mathcal{E}$ that, when closed with j, are within a time window of size $\epsilon$,
    \item ${\llbracket \text{n} \rrbracket}_{\mathcal{E}} = \bigcup\limits_{\bar{p};\\ start(\bar{p}) = n} {\llbracket \bar{p} \rrbracket}_{\mathcal{E}}$ encodes all open complex events ${\llbracket \bar{p} \rrbracket}_{\mathcal{E}}$ with $\bar{p}$ a full-path in $\mathcal{E}$ starting at $n$, and
    \item ${\llbracket \bar{p} \rrbracket}_{\mathcal{E}} = (i, D)$ where $\bar{p} = n_{1},n_{2}, \ldots, n_{k}$ be a \emph{full-path} in $\mathcal{E}$ such that $n_{k}$ is a bottom node, $i = pos(n_{k})$ is the label of the bottom node $n_{k}$, and $D$ is the set of labels of the other non-union nodes in $\bar{p}$.
  \end{itemize}

  First, we prove ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longmapsto paths_{\ge j - \epsilon}(n)$. Given a complex event $([i, j], D) \in {\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$, there is an open complex event $(i, D) \in {\llbracket \text{n} \rrbracket}_{\mathcal{E}}$ that is represented as the full-path $\bar{p} = n_{1},n_{2}, \ldots, n_{k}$ in $\mathcal{E}$ such that $n_{k}$ is a bottom node and $i = pos(n_{k})$ is the label of the bottom node $n_{k}$. Notice, $n_{1} = n$ is the starting node, $j = pos(n_{1})$ is the label of the starting node $n_{1}$ and closing event $j$ and $j - i \le \epsilon$. By definition, $\bar{p} \in {paths}_{\ge \tau}(n)$.

  Secondly, we prove that ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longmapsfrom paths_{\ge j - \epsilon}(n)$. The proof follows by expanding the definition of ${paths}_{\ge \tau}(n)$ and following the steps of ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longmapsto paths_{\ge j - \epsilon}(n)$'s proof in reverse order.

  Finally, by ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longmapsto paths_{\ge j - \epsilon}(n)$ and ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longmapsfrom paths_{\ge j - \epsilon}(n)$ proofs, ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j) \longleftrightarrow paths_{\ge j - \epsilon}(n)$ immediately holds.

\end{proof}

\aref{algo:enumeration} receives as an input a \acrshort{tecs}, a node $n$, a time-window $\epsilon$, a position $j$, and a process $p$ and traverses $G_{\mathcal{E}}$ in a DFS way and left-to-right order i.e. for every union node $u$, the paths of $left(u)$ are traversed before the ones of the $right(u)$. First, computes the parameters $\sigma, \delta, \tau$ corresponding to the starting and ending path to enumerate and the time-window threshold, respectively. Each iteration of the \code{while} of line~\ref{line:enumeration:while:1} traverses a new path starting from the point it branches from the previous path, except for the first iteration that starts from node $n$. For this, the stack $st$ is used to store the node and partial complex event of that branching point. Then, the \code{while} of line~\ref{line:enumeration:while:2} traverses through the nodes of the next path, following the left direction whenever a union node is reached and adding the right node to the stack whenever need. The \code{if}s of line~\ref{line:enumeration:if:1}~and~line~\ref{line:enumeration:if:2} make sure that enumeration starts on path $\pi_{\sigma}$ so only $paths_{\ge j - \epsilon, \sigma, \delta}$ are traversed, otherwise, forcing the next branch with \code{break}. Moreover, by checking for every node $n'$ its value $max(n')$ before adding it to the stack, it makes sure of only going through paths in $paths_{\ge j - \epsilon, \sigma, \delta}$.

A simpler recursive algorithm could have been used, however, the constant-delay output might not be guaranteed because the number of backtracking steps after branching might be as long as the longest path of $G_{\mathcal{E}}$. To guarantee constant steps after branching and assure constant-delay output, \aref{algo:enumeration} uses a stack which allows to jump immediately to the next branch. We assume that storing $P$ in the stack takes constant time. We materialize this assumption by modelling $P$ as a linked list of positions, where the list is ordered by the last element added. To update $P$ with position $i$, we only need to create a node $i$ that points to the previous last element of $P$. Then, storing $P$ on the stack is just storing the pointer of the last element added.

In the reminding of this section, we prove (1), (2) and (3). We start by proving \aref{algo:enumeration} enumerates $paths_{\ge \tau, \sigma, \delta}$ with output-linear delay after $\pi_{\sigma}$, provided that $\mathcal{E}$ is $k$-bounded and time-ordered and $n$ is a duplicate-free node.

\begin{lemma}\label{lemma:enumeration:process}
  Fix $k$, $\mathcal{P}$ and $p \in \mathcal{P}$. Let $\mathcal{E}$ be a $k$-bounded and time-ordered \acrshort{tecs}, $n$ a node of $\mathcal{E}$, and $\epsilon$ a time-window. Then, \aref{algo:enumeration} enumerates $paths_{\ge \tau, \sigma, \delta}$ with output-linear delay after $\pi_{\sigma}$.
\end{lemma}

\begin{proof}
  Fix $\mathcal{E}$, $\tau$, $\sigma$ and $\delta$. We showed that \aref{algo:enumeration} traverses all paths of $paths_{\ge \tau, \sigma, \delta}(n)$. Furthermore, the order in which the paths are traversed is completely determined by the order of the union nodes: for each union node $u$, the paths to its left are traversed first, and then the ones to its right. Formally, for every node $n'$ define the leftmost path from $n'$ as ${\pi_{\swarrow}(n') := n_{0} \rightarrow n_{1} \rightarrow \ldots \rightarrow n_{l}}$ such that $n_{0} = n'$ and, for every $i \le l$:

  \begin{itemize}
      \item if $n_{i} \in N_{B}$, then $i = l$,
      \item if $n_{i} \in N_{O}$, then $n_{i+1} = next(n_{i})$, and
      \item if $n_{i} \in N_{U}$, then $n_{i+1} = left(n_{i})$.
  \end{itemize}

  For the first path, though, the order is different because the algorithm needs to skip all path before $\pi_{\sigma}$. Formally, for every node $n'$ define the leftmost path from $n'$ after $\pi_{\sigma}$ as ${\pi_{\swarrow > \sigma}(n') := n_{0} \rightarrow n_{1} \rightarrow \ldots \rightarrow n_{l}}$ such that $n_{0} = n'$ and, for every $i \le l$:
  \begin{itemize}
      \item if $n_{i} \in N_{B}$, then $i = l$,
      \item if $n_{i} \in N_{O}$, then $n_{i+1} = next(n_{i})$, and
      \item if $n_{i} \in N_{U}$ and $paths(n_{i}) > \sigma$, then ${n_{i+1} = left(n_{i})}$, otherwise, ${n_{i+1} = right(n_{i})}$.
  \end{itemize}

  Consider a path $\pi := n_{0} \rightarrow n_{1} \rightarrow \ldots \rightarrow n_{l}$, and let $j \leq l$ be the last position such that $n_{j}$ is a union node, $n_{j+1} = left(n_{j})$, $max(right(n_{j})) \ge \tau$, and $paths(n_{j}) > \sigma$. Then, let $\pi^{u}_{j}$ be the path $\pi$ up to position $j$ i.e. that stops at such union node.

  Let $P = \{\pi_{1}, \pi_{2}, \ldots, \pi_{\delta}\}$ be the set of paths enumerated by \aref{algo:enumeration} in that order. Then, by analysing \aref{algo:enumeration}, one can see that $\pi_{1} = \pi_{\swarrow > \sigma}(n)$ and, for every $i \le \delta$, $\pi_{i} = \pi^{u}_{i-1} \cdot \pi_{\swarrow}(right(u))$. To put it another way, after reaching the starting path $\pi_{\sigma}$, it performs a greedy DFS from left to right: the first path to enumerate is $\pi_{1} = \pi_{\swarrow > \sigma}(n)$, then each $\pi_{i}$ is the path in ${paths}_{\ge \tau, \sigma, \delta}(n)$ that branches from $\pi_{i-1}$ to the right at the deepest level $u$ and from there follows the leftmost path. Moreover, to jump from $\pi_{i-1}$ to $\pi_{i}$, the node popped by the stack is exactly $u$, that is, the last node of $\pi^{u}_{i-1}$.

  To show that the enumeration is done with output-linear delay after enumerating the first path, we study how long it takes between enumerating the complex events of $\pi_{i-1}$ and $\pi_{i}$. Consider that $\pi_{i-1}$ was just traversed and its complex event was output by line~\ref{line:enumeration:output}. Then, the \code{break} of line~\ref{line:enumeration:break} is executed, breaking the \code{while} of line~\ref{line:enumeration:while:2}. Afterwards, either the stack is empty and the algorithm ends, or a pair $(n', P)$ is popped from the stack, where $n'$ corresponds to the last node of $\pi^{u}_{i-1}$. From that point, it is straightforward to see that the number of iterations of the while of line~\ref{line:enumeration:while:2} (each taking constant time) is equal to the number of nodes $l$ in $\pi_{\swarrow}(n')$, so those nodes are traversed and the complex event of the path $\pi_{i}$ is output. But, because $\mathcal{E}$ is $k$-bounded, then $l \le k \cdot |C|$, where $C$ is the complex event of $\pi_{i}$. Finally, the time taken is bounded by the size of the output, and the enumeration is performed with output-linear delay after reaching the first path.
\end{proof}

Then, we present Lemma~\ref{lemma:bijection_subpath} that follows from Theorem~\ref{theorem:bijection} which will be necessary in the following proof of Theorem~\ref{theorem:enumeration:process}.

\begin{lemma}[${paths}_{\ge j-\epsilon, \sigma, \delta} \rightarrow {\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$]\label{lemma:bijection_subpath}
  For every path in ${paths}_{\ge j-\epsilon, \sigma, \delta}$ there exist exactly one complex event in ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ within a time window of size $\epsilon$ that starts at event $pos(b)$ and ends at event $j$.
\end{lemma}

\begin{proof}
  By definition ${paths}_{\ge j-\epsilon, \sigma, \delta} \subseteq {paths}_{\ge j-\epsilon}$ and Theorem~\ref{theorem:bijection}, ${paths}_{\ge j-\epsilon, \sigma, \delta} \longleftrightarrow S$ where $S \subseteq {\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$. Hence, ${paths}_{\ge j-\epsilon, \sigma, \delta} \rightarrow {\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$.
\end{proof}

Now, we can finally prove that \aref{algo:enumeration} enumerates a subset of ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ of size $\Omega(\frac{{\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j))}{|\mathcal{P}|})$ with output-linear delay after the first complex event, provided that $\mathcal{E}$ is $k$-bounded and time-ordered and $n$ is a duplicate-free node.

\begin{theorem}\label{theorem:enumeration:process}
  Fix $k$, $\mathcal{P}$ and $p \in \mathcal{P}$. Let $\mathcal{E}$ be a $k$-bounded and time-ordered \acrshort{tecs}, $n$ a node of $\mathcal{E}$, $\epsilon$ a time-window. Then, \aref{algo:enumeration} enumerates a subset of ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ of size $\Omega(\frac{{\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j))}{|\mathcal{P}|})$ with output-linear delay after the first complex event.
\end{theorem}

\begin{proof}
  Fix $\tau$. Let $\delta = \frac{paths_{\ge \tau}(n)}{|\mathcal{P}|}$ and $\sigma = index(p) \cdot \delta$ be constants as in \aref{algo:enumeration}. By Lemma~\ref{lemma:enumeration:process}, \aref{algo:enumeration} enumerates $paths_{\ge \tau, \sigma, \delta}$ with output-linear delay after $\pi_{\sigma}$. We need to prove that: (1) $paths_{\ge \tau, \sigma, \delta}$ corresponds to a subset $S$ of ${\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$ and (2) $|S| = \Omega(\frac{{\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j))}{|\mathcal{P}|})$.

 \begin{itemize}
   \item (1) By Lemma~\ref{lemma:bijection_subpath}, immediately follows that $paths_{\ge \tau, \sigma, \delta}$ corresponds to a subset $S \subseteq {\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$.
   \item (2) $S$ is of size at most $\frac{paths_{\ge \tau}(n)}{|\mathcal{P}|}$ because \aref{algo:enumeration} enumerates the set $paths_{\ge \tau, \sigma, \delta}$ of size at most $\delta$ (recall that $\delta = \frac{paths_{\ge \tau}(n)}{|\mathcal{P}|}$), and by Theorem~\ref{theorem:bijection}, $|S|$ is at most of size $\frac{{\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j))}{|\mathcal{P}|}$.
 \end{itemize}

 The output-linear delay follows from the fact that \aref{algo:enumeration} enumerates with output-linear delay after $\pi_{\sigma}$ i.e. the first complex event.
\end{proof}

There is only left to prove (3). We start with Lemma~\ref{lemma:union_of_paths} and finish with Theorem~\ref{theorem:enumeration}.

\begin{lemma}\label{lemma:union_of_paths}
  Let $\mathcal{E}$ be a time-ordered \acrshort{tecs}, $n$ a duplicate-free node of $\mathcal{E}$, $\epsilon$ a time-window, $\mathcal{P}$ the set of all processes. Let $P_{p} = paths_{\ge \tau, \sigma, \delta}(n)$ be the output of \aref{algo:enumeration} on process $p \in \mathcal{P}$. Then, $\bigcup\limits_{p \in \mathcal{P}} P_{p} = paths_{\ge \tau}(n)$.
\end{lemma}

\begin{proof}
  Fix $\tau$ and $\mathcal{P}$.

  Recall that, for every node $n$ in $\mathcal{E}$, ${paths}_{\ge \tau}(n) = \{ \pi_{0}, \pi_{1}, \ldots, \pi_{m} \}$ and ${paths}_{\ge \tau, \sigma, \delta}(n) \subseteq {paths}_{\ge \tau}(n)$ of size at most $\delta$ starting after path $\pi_{\sigma}$ i.e. $\{ \pi_{\sigma}, \pi_{\sigma+1}, \ldots, \pi_{\sigma+\delta}\}$.
  Let $paths_{\ge \tau}(n) = m$, and $\delta = \frac{m}{|\mathcal{P}|}$, $\sigma = index(p) \cdot \delta$ be constants as in \aref{algo:enumeration}.
  For every process $p \in \mathcal{P}$, Lemma~\ref{lemma:enumeration:process} states that \aref{algo:enumeration} enumerates $paths_{\ge \tau, \sigma, \delta}$ where $\sigma$ and $\delta$ are variables that depend on $p$ and $P$, respectively.

  Let $P_{0} = paths_{\ge \tau, 0, \delta}(n)$ be the output of process $0$, $P_{1} = paths_{\ge \tau, \delta, 2\cdot\delta}(n)$ be the output of process $1$, \ldots, $P_{|\mathcal{P}| - 1} = paths_{\ge \tau, (|\mathcal{P}| - 1) \cdot \delta, |\mathcal{P}| \cdot \delta}(n)$ be the output of process $|\mathcal{P}| - 1$, i.e. process $0$ enumerates $\{ \pi_{0}, \ldots \pi_{\delta-1} \}$ , process $1$ enumerates $\{\pi_{\delta}, \ldots \pi_{2 \cdot \delta-1}\}$, \ldots, process $|\mathcal{P}| - 1|$ enumerates $\{\pi_{(|\mathcal{P}| - 1) \cdot \delta}, \ldots, \pi_{m}\}$.
  Then, the union of all the outputs corresponds to the set of paths $\{ \pi_{0}, \ldots, \pi_{m} \}$.
  And so, $\bigcup\limits_{p \in \mathcal{P}} P_{p} = paths_{\ge \tau}(n)$.
\end{proof}

\begin{theorem}\label{theorem:enumeration}
  Let $\mathcal{E}$ be a time-ordered \acrshort{tecs}, $n$ a duplicate-free node of $\mathcal{E}$, $\epsilon$ a time-window, $\mathcal{P}$ the set of all processes. Let $C_{p}$ be the output of \aref{algo:enumeration} on process $p \in \mathcal{P}$. Then, $\bigcup\limits_{p \in \mathcal{P}} C_{p} = {\llbracket \text{n} \rrbracket}^{\epsilon}_{\mathcal{E}}(j)$.
\end{theorem}

\begin{proof}
  TODO
\end{proof}

This concludes the proves of (1), (2), and (3).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Chapter summary}

TODO
