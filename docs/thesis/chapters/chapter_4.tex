\chapter{Distributed CER}\label{chapter:distributed-cer}

In this chapter we propose a novel framework for distributed CER based on the following discussion: given the efficient evaluation of CEA in a centralized manner \cite{formal-framework-cer, core}, it is hard to foresee scenarios where it can benefit from distribution. Indeed, both automata distribution approaches (i.e., query partitioning and pipelining) will incur a big overhead in terms of network communication during the evaluation process to synchronize the compact data structure representing the partial matches, and the enumeration process. However, as previously discussed, CEA is very limited in terms of filtering capabilities, allowing only \emph{unary} predicates. Thus, one might wonder how to include the evaluation of more complex filters over non-unary predicates such as binary predicates (e.g., an equi-join \code{h1[id] = t2[id]}), or second-order predicates (e.g., the sequence of \code{T[val]} must monotonically increase). In \cite{on-the-expressiveness}, it is discussed that CEL and CEA are equivalent in expressive power when CEL is restricted to unary predicates, but incomparable in general. Thus, non-unary CEL, in general, cannot be compiled into an equivalent CEA. However, one could split the pattern matching process and the filtering in CER. In other words, we would maintain the generation of complex events in CEA, but leverage on a distributed framework for complex filtering.

\section{Distributed CER framework}\label{sec:framework}

In this section we describe our proposal for a framework for distributed CER. Our framework uses CEQL as its query language, but we allow $n$-ary CEL predicates inside the \code{WHERE} clause. It receives a stream of data-tuples and a query as an input.  The query is parsed using any context free grammar parsing algorithm (e.g., Earley's algorithm \cite{earley}). The resulting abstract syntax tree (AST) is applied to the \emph{rewrite algorithm}. The rewrite algorithm translates the non-unary CEL predicate of a CEQL query into a unary CEL predicate, and additionally outputs a data structure encoding the corresponding non-unary predicates, if any, to be applied later. The resulting CEQL query is compiled into a CEA by \cite[Theorem~6.2]{formal-framework-cer}. Then, this CEA and the input stream are evaluated using one the efficient evaluation algorithms presented in \cite{formal-framework-cer, core}. Notice, the results of this evaluation is not yet a valid output since we still need to apply the \code{FILTER} clause for the non-unary predicates, if present. Afterwards, the resulting set of complex events is filtered distributedly. Each processing unit applies the \emph{refine algorithm} to its assigned complex events. The refine algorithm uses the non-unary predicates to filter the complex events. Finally, each processing unit enumerates the set of complex events corresponding to the input query.

\textbf{Note}. We implemented a rewrite and refine algorithm that only works for very specific queries. Implementing a generic rewrite and refine algorithm is outside of the scope of this thesis and it is left for future work.

It is clear that the refine algorithm has to be applied distributedly in order to achieve optimal scalability and performance.
However, there are still two relevant decisions left: where do you compile and process the CEA and how do you distribute the resulting complex events among the processing units. We propose two different architectures that take different answers to previous questions. The first architecture, called \emph{Distributed CER Engine (DCERE for short)}, compiles and executes the CEA in a centralized manner and distributes the resulting complex events to each processing unit. The second architecture, called \emph{Distributed CORE (DCORE for short)}, broadcast the events, and compiles and executes the CEA on each processing unit. We remark that implementing the latter is more challenging than implementing the former. For the former, we could use any state-of-the-art sequential evaluation algorithm (e.g. \cite{formal-framework-cer}, or \cite{core}). However, the latter requires an efficient distributed evaluation algorithm for CEA, that to the best of our knowledge, is yet to be discovered.

The rest of this chapter is dedicated to explaining in detail both systems.

\section{Distributed CER Engine}\label{sec:dcere}

\begin{figure}[H]
  \centering
  \inputtikz{dcere}
  \caption{Distributed CER Engine architecture.}
  \label{fig:dcere}
\end{figure}

In this section we discuss \emph{Distributed CER Engine (DCERE)}, an implementation of the framework proposed in Section~\ref{sec:framework} (illustrated in Figure~\ref{fig:dcere})

This implementation is built on top of a distributed actor model. We emphasize that actor models can be used to either encode parallelism by considering each core of a processor as an actor, or distributed programming by considering each processing unit in the network as an actor. Indeed, in the implementation from Chapter~\ref{chapter:experimental_evaluation}, we consider as many actors as the product of the number of processing units in our cluster by the number of cores of each processor.

We will differentiate between two roles of actors: master actors and slave actors. There will be a single master actor in the cluster, and as many slave actors as processing units left. The master actor will act as the leader of the cluster and will orchestrate the rest of the slave actors. The master actor receives a stream of data-tuples and a query as an input. It parses and rewrite the input query to unary CEL. Then, it compiles the query to CEA, and evaluate it to retrieve the corresponding set of complex events. For the compilation and evaluation, we will reuse CORE \cite{core} which guarantees constant update of the data structure and output-linear delay enumeration, and outperforms the other automaton-based engines. Then, we apply one of the selection strategies (explained below) to distribute the set of complex events among the slave actors. Asynchronously and independently, each processing unit receives its corresponding subset of complex events and it applies the refine algorithm to the complex events. Afterwards, once the refine algorithm is finished, the actor returns the resulting subset of complex events to the master node. Finally, once the master has received the output of all processing units, it executes the configured response (e.g., write the complex events to disk, send an email, activate an alarm).

\subsection{Distribution Strategies}\label{subsec:dcere:distribution-strategies}

In this section we describe the distributions strategies used by DCERE to distribute the set of complex events among the set of actors on the distributed system. We have considered distribution strategies ranging from \emph{load-balancing algorithms} to \emph{stream partitioning algorithms}. Additionally, we have proposed our own novel distribution strategy specific to the distribution of complex events, called \emph{Maximal Complex Event Enumeration (MCEE)}. In Chapter~\ref{chapter:experimental_evaluation}, we compare the proposed selection strategies.

\textbf{Round Robin}. \emph{Round Robin (RR)} is the most basic load-balancing strategy. It consist of blindly routing the complex events to the actors in a circular fashion. Although simple, it works well in practice.

\textbf{Power of Two Choices}. The \emph{Power of Two Choices (PoTC)} \cite{load-balancing-1} is a randomized load balancing algorithm introduced in \emph{queue theory}. Given $n$ actors, for each each complex event, we randomly pick $d$ actors. Finally, from those $d$ choices, we pick the one with lowest workload. Surprisingly, having $d = 2$ choices leads to an exponential improvement in the load-balance, whereas $d > 2$ choices is only constant factor better than $d = 2$.

\textbf{Exact Search}. \emph{Exact Search (ES)} is a load balancing algorithm equivalent to PoTC when $d = n$. This distribution strategy was designed taking into account that computing the static load of an actor is cheap, while computing the dynamic load is not. Therefore, for each complex event, we query the static load in constant time of all the actors of the system, and send the complex event to the actor with lowest workload.

\textbf{Maximal Complex Event Enumeration}. \emph{Maximal Complex Event Enumeration (MCEE)} is a load balancing algorithm specific to CER.

\begin{algorithm}[H]
  \setstretch{0.9} % space between lines
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{MCEE}{\textsc{MaximalComplexEventEnumeration}}
  \SetKwFunction{Configurations}{\textsc{Configurations}}
  \SetKwFunction{Head}{head}
  \SetKwFunction{Type}{type}
  \SetKwFunction{Last}{last}
  \SetKwFunction{Enum}{enum}
  \SetKwFunction{OrdTypes}{ordered-types}

  \Procedure{\MCEE{$C_{V}$, $W$}}{
    \KwIn{A set of maximal complex events $\mathcal{C}_{V} := \{C^{1}_{V}, \ldots, C^{n}_{V}\}$ \newline
      and a set of workers $\mathcal{W} := \{W_{1},\ldots, W_{m}\}$.
    }
    \KwResult{Enumerates all \emph{complex events} $C_{V} \subseteq \mathcal{C}_{V}$.}
    $\mathcal{K} \leftarrow \emptyset$\;
    \ForEach{$C_{V} \in \mathcal{C}_{V}$}{
        $\mathcal{K} \leftarrow \mathcal{K} \cup \textsc{Configurations}(C_{V}).map(\lambda K \to ( K, C_{V} ))$\;
    }
    $D \leftarrow K.groupBy(\lambda (K, \_ ) \to K)$\;
    $\textsc{Distribute}(W, D)$
  }
  \;
  \Procedure{\Configurations{$C_{V}$}}{
    \KwIn{A complex event $C_{V} = \{i, \ldots, j\}$ with $C_{V} \subseteq 2^{\mathbb{N}}$.}
    \KwOut{A set $\mathcal{K}$ of configurations $K := T \times \mathbb{N}$ where $K$ is the mapping from the event type $t \in T$ to the size of the group of consecutive events of type $t$ in the complex $C_{V}$.}
    $\mathcal{V} \leftarrow \emptyset$\;
    $i \cup C_{V}' \leftarrow \Head{$C_{V}$}$\;
    $A \leftarrow \{ i \}$\;
    $\Type{$A$} \leftarrow \Type{$i$}$\;
    \For{$j \in C_{V}'$}{
      \eIf{$\Type{$j$} = \Type{$A$}$}{
        $A \leftarrow A \cup j$\;
        \uIf{$\Last{$C_{V}$} = j$} {
          $\mathcal{V} \leftarrow \mathcal{V} \cup \Enum{$1, |A|$}$
        }
      }{
        $\mathcal{V} \leftarrow \mathcal{V} \cup \Enum{$1, |A|$}$\;
        $A \leftarrow \{ j \}$\;
        $\Type{$A$} \leftarrow \Type{$j$}$\;
      }
    }
    $\mathcal{W} \leftarrow \bigtimes\limits_{V \in \mathcal{V}} V$\;
    $T \leftarrow \OrdTypes{$C_{V}$}$\tcp*[l]{\scriptsize e.g., $\OrdTypes{$A_{1}A_{2}B_{1}C_{1}$} = \{A,B,C\}$}
    $\mathcal{K} \leftarrow \emptyset$\;
    \ForEach{$W \in \mathcal{W}$}{
      $K \leftarrow \emptyset$\;
      \For{$i \leftarrow 1$ \KwTo $|W|$}{
        $K \leftarrow K \cup (T[i], W[i])$\;
      }
      $\mathcal{C} \leftarrow \mathcal{C} \cup C$\;
    }
    \Return{$\mathcal{C}$}
  }
\caption{Distributed enumeration of a set of maximal complex events $C_{V}$ over a set of workers $W$.}
\label{algo:mcee:1}
\end{algorithm}

% This procedure enumerates all submatches of M without repetitions.
% It stills enumerates all submatches but only outputs non-repeated.
% It efficiently detects repetitions by constructing an n-ary tree of complex events.
% The complexity is still exponential w.r.t. the size of the largest iteration.
% The exponential time enumeration must be repeated a constant factor of times.
\begin{algorithm}[H]
  \setstretch{0.9} % space between lines
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \SetKwFunction{Enumeratee}{\textsc{Enumerate'}}
  \SetKwFunction{GroupBy}{group-by}
  \SetKwFunction{Type}{type}
  \SetKwFunction{Event}{event}
  \SetKwFunction{Children}{children}
  \SetKwFunction{Add}{add}
  \SetKwFunction{NewNode}{new-node}
  \Procedure{\Enumerate{$D$}}{
    \KwData{A set of tuples $D = \{ \langle K, \mathcal{C}_{V} \rangle \}$ where $K$ is a configuration and $\mathcal{C}_{V}$ is a set of maximal complex events.}
    \KwOut{The set of all complex events $C_{V} \in D$ without duplicates.}
    \ForEach{$(K, \mathcal{C_{V}}) \in A$}{
      $T \leftarrow$ \text{\NewNode{}}\;
      \ForEach{$C_{V} \in \mathcal{C}_{V}$}{
        $\mathcal{G} \leftarrow \GroupBy{$M_V$})$\;
        $\textsc{Enumerate'}(T, \mathcal{G}, \emptyset, \bot, K)$\;
        }
    }
  }
  \;
  \Procedure{\Enumeratee{$n, \mathcal{G}, S, new, K$}}{
    \KwData{A node $n$, a set of grouped events $\mathcal{G}$, a partial complex event $C_{V}$, a boolean $new$, and a configuration $K$.}
    \Switch{$\mathcal{G}$}{
      \uCase{$\emptyset$}{
        \If{$new$}{
          \Return{$C_{V}$}
        }
      }
      \uCase{$G \cup \mathcal{G}$}{
        $k \leftarrow K(\Type{G})$\;
        $N \leftarrow \binom{G}{k}$\;
        \ForEach{$i \in N$}{
          \eIf{$\exists n' \in \Children{n}. \ \ \Event{n'} = i$}{
            $\textsc{Enumerate'}(n', \mathcal{G}, C_{V} \cup i, new)$\;
          }{
            $n' \leftarrow $\NewNode{$i$}\;
            $\Add{\Children{n}, n'}$\;
            \textsc{Enumerate'}$(n', \mathcal{G}, C_{V} \cup i, \top, K)$\;
          }
        }
      }
    }
  }
  \;
\caption{Enumeration of a set of maximal complex events given a predicate configuration.}
\label{algo:mcee:2}
\end{algorithm}

% You need to make the following observations of "Maximal Matches Enumeration":
% 1. The algorithm produces disjoint submatches given a maximal match.
% 2. The algorithm produces non-disjoint submatches given multiple maximal matches.

% But (2) can be analyzed further:
% 1. Disjoint configurations produce disjoint submatches.
% 2. Non-disjoint configurations produce non-disjoint submatches.

% From previous observations we can conclude that repeated submatches are only generated by applying the same configuration to different maximal matches.

% Uniqueness of submatches is guaranteed by (3) and (4).
% (3) guarantees that the output of each worker is disjoint wrt the others.
% (4) guarantees that the output of a worker is disjoint.

% The complexity of the algorithm remains the same if we accomplish linear time enumeration in each worker (this is the tricky part).

\section{Distributed CORE}\label{sec:dcore}

\begin{figure}[H]
  \centering
  \inputtikz{dcore}
  \caption{Distributed CORE architecture.}
  \label{fig:dcore}
\end{figure}

In this section we discuss \emph{Distributed CORE (DCORE)}, an implementation of the framework proposed in Section~\ref{sec:framework}. This implementation is also built on top of a distributed actor model, but the master actor plays a secondary role. It is only used to retrieve the complex events from the rest of the slave actors in order to execute the configured response. Indeed, if the response can be executed on the slaves actors (e.g., writing to an output stream), then the master actor can be removed from the system. We assume that the system can duplicate the input data. Otherwise, assume that the master node receives as an input a stream and a query, and \emph{broadcasts} them to the rest of the actors (illustrated in Figure~\ref{fig:dcore}).

The following steps are all execute asynchronously and independently on each node of the distributed system, and there is no communication between the nodes throughout this process. Each node in the system: receives an input stream and a query, parses and rewrites the input query to unary CEL, compiles the query to CEA, and finally evaluates the CEA, applies the refine algorithm and enumerates the resulting complex events.

In this implementation, the refine algorithm is executed at the same time as the enumeration process (corresponding to $\mathcal{A} \to C'_{1}$ in Figure~\ref{fig:dcore}), not requiring and additional traversal of the complex events. In other words, the output of the evaluation algorithm is already the output corresponding to the complex events captured by our query.

We emphasize that our system needs to evaluate, filter and enumerate disjoint subsets of complex events; otherwise, this implementation would be equivalent to a sequential version, but slower. For this reason, we require an efficient distributed evaluation algorithm for CEA. But, as far as we are concerned, such an algorithm does not exist. For this reason, we devote Chapter~\ref{chapter:algorithm} to the design of such an algorithm.

\section{Chapter summary}

In this chapter, we presented a framework for distributed CER. Then, we discussed how a distributed framework for automaton-based CER would look like, and described our proposal for such a framework. Later, we introduced DCERE, an implementation of our framework and described several distribution strategies. Finally, we introduced DCORE, another implementation of our framework, and motivated the search for a distributed evaluation algorithm for CEA.
