\chapter{???}\label{chapter:???}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Distribution strategies}\label{sec:distribution_strategies}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Distributed enumeration of complex events}
\label{sec:distributed_enumeration_of_the_complex_events}

CORE's evaluation algorithm guarantees, under data complexity, constant time per event and constant-delay enumeration of the output \cite{core}. However, the amount of complex events can grow exponentially in the size of the stream; therefore enumerating all complex events generated by an event is exponential in the worst-case \cite{grez_et_al:LIPIcs:2019:10307}.

In order to speed up the matching process, it is common to restrict the set of results \cite{10.1016/j.scico.2010.06.010, 10.1145/1142473.1142520, Zhang2014OnCA}. Sadly, most proposals in the literature introduce heuristics to a particular computational model without describing how the semantics are affected. A more general approach, \textit{selection strategies} as unary operators over core-CEL formulas was introduced in \cite{grez_et_al:LIPIcs:2019:10307}. Four selection strategies called strict (\textsc{strict}), next (\textsc{nxt}), last (\textsc{last}) and max (\textsc{max}) were defined and their formally semantic was given in \cite{grez_et_al:LIPIcs:2019:10307}. The application of selection strategies to the computational model of CEL, called \gls{cea}, has been studied in \cite{grez_et_al:LIPIcs:2019:10307}. However, the impact on the enumeration process has not.

% \begin{theorem}[{\cite[Theorem~5]{grez_et_al:LIPIcs:2019:10307}}]
%   Let \textsc{sel} be a selection strategy. For any $CEA \ \mathcal{A}$, there is a $CEA \ A_{\textsc{sel}}$ equivalent to $\textsc{sel}(\mathcal{A})$. Furthermore, the size of $\mathcal{A}_{\textsc{sel}}$ is, with respect to the size of $\mathcal{A}$, at most linear if $\textsc{sel} = \textsc{strict}$, and at most exponential otherwise.
% \end{theorem}

We present an informal analysis of the selection strategies (strict, next, last and max) on the enumeration of the complex events, and defer a more elaborated analysis for future work.

% TODO
We observed, that in the presence of iterations, all previous for strategies still suffer exponential growth in the number of complex events to be enumerated.

In order to deal with the exponential complexity of enumerating complex events in CER, we propose the distributed enumeration Algorithm \ref{algo:mmde}.

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{MMDE}{\textsc{MaximalMatchesDisjointEnumeration}}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}

  \Procedure{\MMDE{$M$, $W$}}{
    \KwIn{A set of maximal matches $M := \{M_{1}, \ldots, M_{n}\}$ \newline
      and a set of workers $W := \{w_{1},\ldots, w_{m}\}$.
    }
    \KwResult{Enumerates all \textit{submatches} $\subseteq M$ without repetitions.}
    $C \leftarrow \emptyset$\;
    \ForEach{$M_{i} \in M$}{
        $C \leftarrow C \cup \textsc{Configurations}(M_{i}).map(\lambda c \to ( c, M_{i} ))$\;
    }
    $D \leftarrow C.groupBy(\lambda (c, \_ ) \to c)$\;
    $\textsc{Distribute}(W, D)$\tcp*[l]{\textit{Round-robin, Bins \& Balls, etc.}}
    \ForEach{$w \in W$}{
      \tcp{\textsc{Enumerate} is executed in a remote machine}
      $w.\textsc{Enumerate}()$
    }
  }
  \;
\caption{Non-repeated enumeration of a set of maximal matches.}
\label{algo:mmde}
\end{algorithm}

% This procedure enumerates all submatches of M without repetitions.
% It stills enumerates all submatches but only outputs non-repeated.
% It efficiently detects repetitions by constructing an n-ary tree of complex events.
% The complexity is still exponential w.r.t. the size of the largest iteration.
% The exponential time enumeration must be repeated a constant factor of times.
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Enumerate}{\textsc{Enumerate}}
  \SetKwFunction{Enumeratee}{\textsc{Enumerate'}}

  \Procedure{\Enumerate{}}{
    \KwData{A set of tuples $A = \{ (c, \{ M_{1}, \ldots, M_{n}\}) \}$ where $c$ is a \textit{configuration} and $M_{i}$ are maximal matches.}
    \KwOut{The set of all submatches without repetitions.}
    \ForEach{$(c, M) \in A$}{
      $T \leftarrow$ \textit{newRoot()}\tcp*[l]{Root of a \textit{n}-ary tree}
      \ForEach{$M_{i} \in M$}{
        $G \leftarrow \textsc{GroupBy}(M_{i})$\tcp*[l]{$\textsc{GroupBy}(A_{1}A_{2}B_{1}B_{2}C_{1}) = \{ \{A_{1}, A_{2}\}, \{B_{1}, B_{2}\}, \{C_{1}\} \}$}
        }
        $\textsc{Enumerate'}(T, G, \emptyset, \bot)$
    }
  }
  \;
  \Procedure{\Enumeratee{$n, G, S, new$}}{
    \KwData{A node $n$, a set of grouped events $G$, a time-ordered set of events $S$, and a boolean $new$.}
    \Switch{$G$}{
      \uCase{$\emptyset$}{
        \If{$new$}{
          \Return{$S$}
        }
      }
      \uCase(\tcp*[h]{$e.g. \ g = \{A_{1}, A_{2}\}, \ g.type = A$}){$g \cup G'$}{
        $k \leftarrow c(g.type)$\tcp*[l]{$k \in \mathbb{N}$}
        $E \leftarrow \binom{g}{k}$\tcp*[l]{The \textit{k}-combination set}
        \ForEach{$e \in E$}{
          \eIf{$\exists n' \in n.children \land n'.event = e$}{
            $\textsc{Enumerate'}(n', G', S \cup e, new)$\;
          }{
            $p \leftarrow \text{\textit{new-node}}(e)$\;
            $n.children.add(p)$\;
            $\textsc{Enumerate'}(p, G', S \cup e, \top)$\;
          }
        }
      }
    }
  }
  \;
\caption{Non-repeated enumeration of a set of maximal matches given a predicate configuration.}
\label{algo:enumerate}
\end{algorithm}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoNoEnd % don't print end
  \SetAlgoNoLine % no vertical lines
  \LinesNumbered
  \SetKwProg{Procedure}{procedure}{}{}
  \SetKwFunction{Configurations}{\textsc{Configurations}}

  \Procedure{\Configurations{$M$}}{
    \KwIn{A match $M = \{e_{1}, \ldots, e_{n}\}$ where $e_{i}$ is an event of type $t \in T$.}
    \KwOut{A set $C$ of configurations $c := T \times \mathbb{N}$ where $c$ is the mapping from the event type $t \in T$ to the size of the iteration of the event type $t$ in the submatches of $M$.}
    $V \leftarrow newList$\;
    $e_{0} \cup M' \leftarrow pop(M)$\;
    $A \leftarrow \{ e_{0} \}$\;
    $A.type \leftarrow e_{0}.type$\;
    \For{event $e$ in $M'$}{
      \eIf{$e.type = A.type$}{
        $A \leftarrow A \cup e$\;
        \uIf{$isLast(e)$} {
          $V \leftarrow V + enumFromTo(1, |A|)$
        }
      }{
        $V \leftarrow V + enumFromTo(1, |A|)$\;
        $A \leftarrow \{ e \}$\;
        $A.type \leftarrow e.type$\;
      }
    }
    $WW \leftarrow V_{1} \times \cdots \times V_{n}$\tcp*[l]{$V = \{V_{1}, \cdots, V_{n}\}$}
    $T \leftarrow types(M)$\tcp*[l]{Ordered set of types e.g. $types(A_{1}A_{2}B_{1}C_{1}) = \{A,B,C\}$}
    $C \leftarrow \emptyset$\;
    \ForEach(\tcp*[h]{E.g. $W = \{1, 2, 1\}$}){$W \in WW$}{
      $c \leftarrow \emptyset$\tcp*[l]{E.g. $c = \{(A,1), (B,2), (C, 1)\}$}
      \For{$i \leftarrow 1$ \KwTo $|W|$}{
        $c \leftarrow c \cup (T[i], W[i])$\;
      }
      $C \leftarrow C \cup c$\;
    }
    \Return{C}
  }
\caption{Computes all disjoint configurations of a maximal match.}
\label{algo:configurations}
\end{algorithm}

% You need to make the following observations of "Maximal Matches Enumeration":
% 1. The algorithm produces disjoint submatches given a maximal match.
% 2. The algorithm produces non-disjoint submatches given multiple maximal matches.

% But (2) can be analyzed further:
% 1. Disjoint configurations produce disjoint submatches.
% 2. Non-disjoint configurations produce non-disjoint submatches.

% From previous observations we can conclude that repeated submatches are only generated by applying the same configuration to different maximal matches.

% Uniqueness of submatches is guaranteed by (3) and (4).
% (3) guarantees that the output of each worker is disjoint wrt the others.
% (4) guarantees that the output of a worker is disjoint.

% The complexity of the algorithm remains the same if we accomplish linear time enumeration in each worker (this is the tricky part).

\begin{lemma}[TODO]
  \label{lemma:todo}
  TODO
\end{lemma}

\begin{theorem}[TODO]
  \label{theorem:todo}
  TODO
\end{theorem}

\begin{example}[TODO]
  \label{example:todo}
  TODO
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Chapter summary}

TODO
