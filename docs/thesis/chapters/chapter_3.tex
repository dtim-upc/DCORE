\chapter{Preliminaries}\label{chapter:preliminaries}

In this section, we introduce the formal background that support our study.
First, we introduce \emph{distributed computing}.
Secondly, we describe CEQL and give a formal description.
Thirdly, we briefly discuss \emph{selection strategies}.
Lastly, we introduce the computational model CEA and how to compile unary CEQL to CEA.

\section{Distributed computing}\label{sec:distributed_computing}

A \emph{distributed system} is a system whose components are located on different networked computers that communicate to each other by message passing in order to achieve a common goal. The main three characteristics of a distributed system are: concurrency of the components, lack of global memory and clock, and tolerance to failure of individual components \cite{distributed-computing-book}. Nowadays, the term is used in a much wider sense, even referring to autonomous processes that run on the same physical computer and interact with each other by message passing. In our work, we do not make a distinction on whether the system operators on different networked computers or the same physical computer.

A \emph{distributed program} is composed of an ordered-set of $n$ asynchronous processes $\mathcal{P} = \{ p_{1}, p_{2}, \ldots, p_{n}\}$. For a process $p_{i}$ with $1 \le i \le n$, define its \emph{index}, denoted index($p_{i}$), as index($p_{i}$) = $i \in \mathbb{N}$. The index of a process can be used as a \emph{unique} identifier. The processes do not share a global memory and communicate solely by passing messages. Process execution and message transfer are asynchronous. Without loss of generality, we assume that each process is running on a different processor. Let $C_{ij}$ denote the channel from process $p_{i}$ to process $p_{j}$ and let $m_{ij}$ denote a message sent by $p_{i}$ to $p_{j}$. The message transmission delay is finite and unpredictable \cite{distributed-computing-book}.

\section{Complex event logic}\label{sec:ceql}

\emph{Complex Event Query language (CEQL)} is a practical CER language based on \emph{Complex Event Logic (CEL)}, which is a formal logic that is built from the common operators in the literature of CER and whose expressiveness and complexity have been in-depth studied in \cite{formal-framework-cep,on-the-expressiveness,formal-framework-cer}.\bigskip

\begin{figure}[H]
  \begin{minted}[xleftmargin=120pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT *
    FROM warehouse
    WHERE (T as t1; T+ as ts)
    FILTER t1[tmp < 30]
      AND ts[tmp > 30]
    PARTITION BY id
    WITHIN 5 minutes
  \end{minted}
  \caption{CEQL query on a wireless sensors network stream}
  \label{fig:query}
\end{figure}

We continue with our example of detecting fires in a stream produced by a network of wireless sensors placed in a warehouse. Suppose that we are interested in all triplets of \code{T} events where the first has temperature below $30$ Celsius degrees and the rest has temperature above $30$ Celsius degrees, partitioned by the zone of the warehouse where the sensor is placed. The query from Figure~\ref{fig:query} expresses this in CEQL. The \code{FROM} clause indicates the input streams. The \code{WHERE} clause indicates the pattern of events that need to be matched in the stream. The pattern can be any \emph{unary} CEL expression \cite{formal-framework-cer}. In our query, the pattern \code{T as t1; T+ as ts} indicates that we want to capture all complex events that consist of an event type \code{T} followed by an arbitrary number of events of type \code{T}. In particular, the operator (;) indicates sequencing and the operator (+) indicates non-empty repeated sequencing. We want to remark that sequencing in CEL is non-contiguous. Consequently, the \code{T} events do not need to be contiguous --- there might be other events in between. The \code{FILTER} clause allows to filter events by unary predicates. The clause \code{PARTITION BY} allows to express correlation among events in the form of equi-joins. The \code{WITHIN} clause specifies the time-window. In our query, the time between the first event \code{T} and the last event \code{T} must be within 5 minutes. Finally, the \code{SELECT} clause allows to project the result.

Next, we give the formal syntax and semantics of CEQL.

\textbf{Events, complex events, and valuations}. Fix a set of \emph{event types} \textbf{T} (e.g., \code{H} and \code{T}), a set of \emph{attribute names} \textbf{A} (e.g., $id$, $tmp$, and $hum$), and a set of \emph{data values} \textbf{D} (e.g., integer, strings, etc.). A \emph{data-tuple t} is a partial mapping that maps attribute names from \textbf{A} to data values in \textbf{D}. Each data-tuple is associated to an event type. We denote by $t(a) \in \textbf{D}$ the value of the attribute $a \in \textbf{A}$ assigned by $t$, and by $t(type) \in \textbf{T}$ the event type of $t$. If $t$ is not defined on attribute $a$, then we write $t(a) = \text{NULL}$.

A \emph{stream} is a possibly infinite sequence $S = t_{0}t_{1}t_{2}\ldots$ of data-tuples. Given a set $D \subseteq \mathbb{N}$, we define the set of data tuples $S[D] = \{ t_{i} \ | \ i \in D\}$. A \emph{complex event} is a pair $C = ([i,j], D)$ where $i \le j \in \mathbb{N}$ and $D$ is a subset of $\{i, \ldots, j\}$. Intuitively, given a stream $S = t_{0}t_{1}\ldots$ the interval $[i, j]$ of $C$ represents the subsequence $t_{i}t_{i+1} \ldots t_{j}$ of $S$ where the complex event $C$ happens and $S[D]$ represents the data-tuples from $S$ that are relevant for $C$. We write $C(data)$ to denote $D$, $C(time)$ to denote the time-interval $[i, j]$, $C(data)$, and $C(start)$ and $C(end)$ for $i$ and $j$, respectively.

Let \textbf{X} be a set of \emph{variables}, which includes all event types, $\textbf{T} \subseteq \textbf{X}$. A \emph{valuation} is a pair $V = ([i, j], \mu)$ with $[i,j]$ a time interval as above and $\mu$ a mapping that assigns subsets of $\{i, \ldots, j\}$ to variables in \textbf{X}. We write $V(time)$, $V(start)$, and $V(end)$ for $[i,j]$, $i$, and $j$, respectively, and $V(X)$ for the subset of $\{i,\ldots, j\}$ assigned to X by $\mu$.

We write $C_{V}$ for the complex event that is obtained from valuation $V$ by forgetting the variables in $V$: $C_{V}(time) = V(time)$ and $C_{V}(data) = \bigcup\limits_{X \in \textbf{X}} V(X)$. The semantics of CEQL will be defined in terms of valuations, which are subsequently transformed into complex events as explained.

\textbf{Predicates}. A (unary) \emph{predicate} is a possibly infinite set $P$ of data-tuples. A data-tuple $t$ \emph{satisfies} predicate $P$, denote $t \Vdash P$, if, and only if, $t \in P$. We generalize this definition from data-tuples to sets by taking a ``for all'' extension: a set of data-tuples $T$ satisfies $P$, denoted by $T \Vdash P$, if, and only if, $\displaystyle\mathop{\forall}_{t \in T} t \vDash P$.

\textbf{Syntax}. The abstract syntax of CEQL is the following:

\begin{figure}[H]
  \begin{minted}[xleftmargin=0pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT        [selection strategy] <list of variables>
    FROM          <list of streams>
    WHERE         <CEL formula>
    (PARTITION BY <list of attributes>)?
    (WHITHIN      <time>)?
  \end{minted}
\end{figure}

\vspace{-30pt}
We remark that CEL includes \code{FILTER}, and so CEQL does not need a separate \code{FILTER} clause. The \code{WHERE} clause expects a pattern written in Complex Event Logic (CEL) \cite{formal-framework-cer}, whose abstract syntax is represented by the following grammar:

\vspace{-20pt}
\begin{equation*}
  \varphi := R    \ | \ \varphi \ \text{AS} \ X    \ | \    \varphi \ \text{FILTER} \ X[P]  \ | \   \varphi \ \text{OR} \ \varphi   \ | \  \varphi ; \varphi    \ | \  \varphi+ \ | \ \pi_{L}(\varphi).
\end{equation*}

\vspace{-10pt}
In this grammar, $R$ is an event type in \textbf{T}, $X$ is a variable in \textbf{X}, $P$ is a predicate, and $L$ is a subset of variables in \textbf{X}.

The semantics of CEQL is as follows. A CEQL query first evaluates its \code{FROM} clause, then its \code{PARTITION BY} clause, and subsequently its \code{WHERE, SELECT, WITHIN} clauses, in that order. The \code{FROM} clause specifies the list of streams. All these streams are logically merged into a single stream $S$. The optional \code{PARTITION BY} clause logically partitions this stream into multiple substreams $S_{1}, S_{2}\ldots$ and executes the \code{WHERE-SELECT-WITHIN} clauses on each substream. The union of the outputs generated for each substream constitute the final output.

\textbf{Semantics}. CEQL's \code{WHERE} and \code{FILTER} clause are derived from the semantics of CEL in Figure~\ref{fig:cel:semantics}. Specifically, given a stream $S = t_{0}t_{1}t_{2} \ldots $, a CEL formula $\varphi$ evaluates to a set of valuations, denoted $\InSBrackets{\varphi}(S)$. The base case is when $\varphi$ is an event type $R$. In that case $\InSBrackets{\varphi}(S)$ contains all valuations whose time-interval is a single position $i$, such that the data-tuple $t_{i}$ at position $i$ in $S$ is of type $R$. The \code{AS} clause is a variable assignment that takes an existing valuation $V \in \InSBrackets{\varphi}(S)$ and extends it by gathering all positions $\bigcup_{Y}V(Y)$ in variable $X$, keeping all other variables as in $V$. The \code{FILTER} $X[P]$ clause retains only those valuations for which the content of variables $X$ satisfies predicate $P$. The \code{OR} clause takes the union of two sets of valuations. The sequencing operator ($\varphi;\varphi$) uses the time-interval for capturing all pairs of valuations in which the first is chronologically followed by the second. The semantics of iteration ($\varphi+$) is defined as the application of sequencing ($;$) one or more times over the same formula $\varphi$. The projection $\pi_{L}$ modifies valuations by setting all variables that are not in $L$ to empty. Hence, \code{WHERE-FILTER} return a set of valuations when evaluated over a stream. The \code{SELECT} clause, if it does not mention a selection strategy (explained later), corresponds to a projection in CEL. Finally, if $\epsilon$ is a time-interval, then the \code{WITHIN} clause operate on the resulting set of valuations $\InSBrackets{\varphi \ \text{WITHIN} \ \epsilon}(S) = \{ V \in \InSBrackets{S} \ | \ V(end) - V(start) \le \epsilon \}$.

\begin{figure}[t]
  \begin{align*}
    \InSBrackets{R}(S) &= \{V \ | \ V(time) = [i,i] \land t_{i}(type) = R\\
                       &\qquad\quad \land V(R) = {i} \land \forall X \ne R. V(X) = \emptyset \}\\
    \InSBrackets{\varphi \ \text{AS} \ X}(S) &= \{V \ | \ \exists V' \in \InSBrackets{\varphi}(S). V(time) = V'(time)\\
                       &\qquad\quad \land V(X) = \cup_{Y} V'(Y)\\
                       &\qquad\quad \land \forall Z \ne X. V(Z) = V'(Z)\}\\
    \InSBrackets{\varphi \ \text{FILTER} \ X[P]}(S) &= \{V \ | \ V \in \InSBrackets{\varphi}(S) \land V(X) \vDash P \}\\
    \InSBrackets{\varphi_{1} \ \text{OR} \ \varphi_{2}}(S) &= \InSBrackets{\varphi_{1}}(S) \cup \InSBrackets{\varphi_{2}}(S)\\
    \InSBrackets{\varphi_{1} \ ; \ \varphi_{2}}(S) &= \{V \ | \ \exists V_{1} \in \InSBrackets{\varphi_{1}}(S), V_{1} \in \InSBrackets{\varphi_{2}}(S).\\
                       &\qquad\quad  V_{1}(end) = V_{2}(start)\\
                       &\qquad\quad \land V(time) = [V_{1}(start), V_{2}(end)]\\
                       &\qquad\quad \land \forall X. V(X) = V_{1}(X) \cup V_{2}(X) \}\\
    \InSBrackets{\varphi+}(S) &= \InSBrackets{\varphi}(S) \cup \InSBrackets{\varphi;\varphi+}(S)\\
    \InSBrackets{\pi_{L}(\varphi)}(S) &= \{ V \ | \ \exists V' \in \InSBrackets{\varphi}(S). V(time) = V'(time)\\
                              &\qquad\quad \forall X \in L. V(X) = V'(X) \\
                              &\qquad\quad \forall X \notin L. V(X) = \emptyset \}
  \end{align*}
  \caption{The semantics of CEL.}
  \label{fig:cel:semantics}
\end{figure}

\textbf{Complex event semantics}. The complex event semantics of CEL and CEQL is obtained by first evaluating the query under the valuations semantics, and then removing variables. That is, if $\varphi$ is a CEL formula or CEQL query, its complex event semantics $\InDBrackets{\varphi}(S)$ is defined $\InDBrackets{\varphi}(S) := \{ C_{V} \ | \ V \in \InSBrackets{\varphi}(S)\}$.

\section{Selection strategies}\label{sec:selection_strategies}

\emph{Selection strategies} (or \emph{selectors}) are unary operators over CEL formulas that restrict the set of results and speed up query processing. We present four selection strategies \cite{formal-framework-cep,formal-framework-cer}: \emph{strict} (\textsc{strict}), \emph{next} (\textsc{nxt}), \emph{last} (\textsc{last}) and \emph{max} (\textsc{max}). \textsc{strict} and \textsc{nxt} are motivated by the \emph{strict-contiguity} and \emph{skip-till-next-match} selector strategies proposed by SASE \cite{sase}, while \textsc{last} and \textsc{max} are useful selection strategies from a semantic viewpoint \cite{formal-framework-cer}. Next, we describe and formally specify selection strategy \textsc{max}, as it is relevant in our work, and refer the interested reader to \cite{formal-framework-cer} for a definition and discussion of the other selection strategies. For the sake of the discussion, we will define the \emph{support} of a valuation $V$ as the set of all positions appearing in the range of $V$, i.e., $sup(V) = \bigcup\limits_{X \in \textbf{X}}V(X)$.

\textsc{MAX}. This selection strategy keeps the maximal complex events in terms of set inclusion, which could be naturally more useful because these complex events are the \emph{most informative}. Formally, given a CEL formula $\varphi$ we say that $V \in \InSBrackets{\textsc{max}(\varphi)}(S)$ holds iff $V \in \InSBrackets{\varphi}(S)$ and for all $V' \in \InSBrackets{\varphi}(S)$, if $sup(V) \subseteq sup(V')$, then $sup(V) = sup(V')$ (i.e., $V$ is maximal with respect to set containment). For example, given a CEL query $\varphi$, if $\InSBrackets{\varphi}(S)$ returns $\{ 3,6,7\}$, $\{3,4,7\}$, and $\{3,4,6,7\}$. Then, $\textsc{max}(\varphi)$ will only return $\{ 3, 4, 6, 7\}$, which is the maximal complex event.

\section{Computational model}\label{sec:cea}

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{cea}
    \vspace*{2em}
  \end{subfigure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{stream}
  \end{subfigure}

  \caption{A CEA representing the query from Figure~\ref{fig:query} and an example of stream.}
  \label{fig:cea}
\end{figure}
