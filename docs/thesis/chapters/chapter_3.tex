\chapter{Preliminaries}\label{chapter:preliminaries}

% [ ] Talk about unary CEL formulas.




% Place it
\begin{figure}[H]
  \begin{minted}[xleftmargin=40pt, linenos=false]{text}
    SELECT *
    FROM S
    WHERE A as a; B + as bb
  \end{minted}
  \caption{CEQL query on a synthetic stream S.}
  \label{fig:query:ab+}
\end{figure}

% Here we should talk about: events, complex events, valuations, predicates, second-order predicates, query compilation.

The notion of \textbf{constant-delay enumeration} was defined in the database community \cite{constant-delay-1, constant-delay-2} for defining efficiency whenever generating the output might use considerable time. An enumeration is performed in constant-delay if it takes constant time between any two consecutive solutions. Formally, it requires the existence of a routine \textsc{Enumerate} that receives $t_{j}$ as input and outputs all complex events in $\llbracket n \rrbracket^{\epsilon}_{\mathcal{E}}(j)$ without repetitions, while spending a constant amount of time before and after each output. Naturally, the time to generate a complex event $C$ must be linear in $|C|$.


% Do not explain data complexity
% \textbf{Data complexity}. \quad \emph{Data complexity} is the complexity of evaluating a fixed query in the language under study as a function of the size of the database.

% Data complexity is really a measure for the expressive power of the language because it answers the question ``how difficult are the individual questions asked in this language?''.


In order to speed up the matching process, it is common to restrict the set of results \cite{selection-strategies-literature-1,selection-strategies-literature-2,selection-strategies-literature-3}. Sadly, most proposals in the literature introduce heuristics to a particular computational model without describing how the semantics are affected. In \cite{formal-framework-cer}, a more general approach, \emph{selection strategies} as unary operators over core-CEL formulas, was introduced. Four selection strategies called strict (\textsc{strict}), next (\textsc{nxt}), last (\textsc{last}) and max (\textsc{max}) were formally defined.


A \textbf{distributed program} is composed of an ordered-set of $n$ asynchronous processes $\mathcal{P} = \{ p_{1}, p_{2}, \ldots, p_{i}, \ldots, p_{n}\}$. For a process $p_{i}$, define its \emph{index}, denoted index($p_{i}$), as index($p_{i}$) = $i \in \mathcal{N}$. The processes do not share a global memory and communicate solely by passing messages. Process execution and message transfer are asynchronous. Without loss of generality, we assume that each process is running on a different processor. Let $C_{ij}$ denote the channel from process $p_{i}$ to process $p_{j}$ and let $m_{ij}$ denote a message sent by $p_{i}$ to $p_{j}$. The message transmission delay is finite and unpredictable.



% Place it in CEA section
\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{ceaAB+}
  \end{subfigure}
  \\
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{streamAB+}
  \end{subfigure}

  \caption{A CEA representing the query from Figure~\ref{fig:query:ab+} and an example of stream.}
  \label{fig:cea:ab+}
\end{figure}
