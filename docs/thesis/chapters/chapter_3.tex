\chapter{Preliminaries}\label{chapter:preliminaries}

In this section, we introduce the formal background that support our study.
First, we introduce \emph{distributed computing}.
Secondly, we describe CEQL and give a formal description.
Thirdly, we briefly discuss \emph{selection strategies}.
Lastly, we introduce the computational model CEA and how to compile unary CEQL to CEA.

\section{Distributed computing}\label{sec:distributed_computing}

A \emph{distributed system} is a system whose components are located on different networked computers that communicate to each other by message passing in order to achieve a common goal. The main three characteristics of a distributed system are: concurrency of the components, lack of global memory and clock, and tolerance to failure of individual components \cite{distributed-computing-book}. Nowadays, the term is used in a much wider sense, even referring to autonomous processes that run on the same physical computer and interact with each other by message passing. In our work, we do not make a distinction on whether the system operators on different networked computers or the same physical computer.

A \emph{distributed program} is composed of an ordered-set of $n$ asynchronous processes $\mathcal{P} = \{ p_{1}, p_{2}, \ldots, p_{n}\}$. For a process $p_{i}$ with $1 \le i \le n$, define its \emph{index}, denoted index($p_{i}$), as index($p_{i}$) = $i \in \mathbb{N}$. The index of a process can be used as a \emph{unique} identifier. The processes do not share a global memory and communicate solely by passing messages. Process execution and message transfer are asynchronous. Without loss of generality, we assume that each process is running on a different processor. Let $C_{ij}$ denote the channel from process $p_{i}$ to process $p_{j}$ and let $m_{ij}$ denote a message sent by $p_{i}$ to $p_{j}$. The message transmission delay is finite and unpredictable \cite{distributed-computing-book}.

\section{Complex event logic}\label{sec:ceql}

In this section, we introduce CEQL by means of an example, and then, we give the formal syntax and semantics of CEQL.

\emph{Complex Event Query language (CEQL)} is a practical CER language based on \emph{Complex Event Logic (CEL)}, which is a formal logic that is built from the common operators in the literature of CER and whose expressiveness and complexity have been in-depth studied in \cite{formal-framework-cep,on-the-expressiveness,formal-framework-cer}.

We continue



\begin{figure}[H]
  \begin{minted}[xleftmargin=100pt, linenos=false, fontsize=\scriptsize]{text}
    SELECT *
    FROM S
    WHERE (T as t1; T+ as ts)
    FILTER t1[tmp < 30]
      AND ts[tmp > 30]
    PARTITION BY id
    WITHIN 5 minutes
  \end{minted}
  \caption{CEQL query on a synthetic stream S.}
  \label{fig:query}
\end{figure}

\section{Selection strategies}\label{sec:selection_strategies}

In order to speed up the matching process, it is common to restrict the set of results \cite{selection-strategies-literature-1,selection-strategies-literature-2,selection-strategies-literature-3}. Sadly, most proposals in the literature introduce heuristics to a particular computational model without describing how the semantics are affected. In \cite{formal-framework-cer}, a more general approach, \emph{selection strategies} as unary operators over core-CEL formulas, was introduced. Four selection strategies called strict (\textsc{strict}), next (\textsc{nxt}), last (\textsc{last}) and max (\textsc{max}) were formally defined.

\section{Computational model}\label{sec:cea}

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{cea}
    \vspace*{2em}
  \end{subfigure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{stream}
  \end{subfigure}

  \caption{A CEA representing the query from Figure~\ref{fig:query} and an example of stream.}
  \label{fig:cea}
\end{figure}
