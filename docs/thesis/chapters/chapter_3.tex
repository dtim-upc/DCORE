\chapter{Preliminaries}\label{chapter:preliminaries}

In this section, we introduce the formal background that support our study.
First, we introduce the concepts behind \emph{distributed computing}.
Secondly, we describe CEQL and give a formal description.
Thirdly, we briefly discuss \emph{selection strategies}.
Lastly, we introduce the computational model CEA.

\section{Distributed computing}\label{sec:distributed_computing}

A \emph{distributed system} is a system whose components are located on different networked computers that communicate to each other by message passing in order to achieve a common goal. The main three characteristics of a distributed system are: concurrency of the components, lack of global memory and clock, and tolerance to failure of individual components \cite{distributed-computing-book}. Nowadays, the term is used in a much wider sense, even referring to autonomous processes that run on the same physical computer and interact with each other by exchanging messages. In our work, we do not make a distinction on whether the system operates on a cluster of networked computers or in a single multi-core computer.

A \emph{distributed program} is composed of an ordered-set of $n$ asynchronous processes $\mathcal{P} = \{ P_{1}, P_{2}, \ldots, P_{n}\}$. For a process $P_{i}$ with $1 \le i \le n$, define its \emph{index}, denoted index($P_{i}$), as index($P_{i}$) = $i \in \mathbb{N}$. The index of a process can be used as a \emph{unique} identifier. The processes do not share a global memory and communicate solely by passing messages. Process execution and message transfer are asynchronous. Without loss of generality, we assume that each process is running on a different processor. Let $C_{ij}$ denote the channel from process $P_{i}$ to process $P_{j}$ and let $m_{ij}$ denote a message sent by $P_{i}$ to $P_{j}$. The message transmission delay is finite and unpredictable \cite{distributed-computing-book}.

\section{Complex event logic}\label{sec:ceql}

\emph{Complex Event Query Language (CEQL)} is a practical CER language based on \emph{Complex Event Logic (CEL)}, which is a formal logic that is built from the common operators in the literature of CER and whose expressiveness and complexity have been diligently studied in \cite{formal-framework-cep,on-the-expressiveness,formal-framework-cer}. We introduce the most relevant features of CEQL by means of an example.

\begin{example}
We retake the previous example which aims on the detection of fires in a stream produced by a network of wireless sensors placed in a warehouse. Suppose that we are interested in all $n$-tuples of \code{T} events where the first has temperature below $30$ Celsius degrees and the rest has temperature above $30$ Celsius degrees, partitioned by the zone of the warehouse where the sensor is placed. The query from Figure~\ref{fig:query:2} expresses this in CEQL.

\begin{figure}[H]
  \begin{minted}[xleftmargin=120pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT *
    FROM warehouse
    WHERE (T as t1; T+ as ts)
    FILTER t1[val < 30]
      AND ts[val > 30]
    PARTITION BY id
    WITHIN 5 minutes
  \end{minted}
  \caption{CEQL query on a wireless sensors network stream.}
  \label{fig:query:2}
\end{figure}

The \code{FROM} clause indicates the input streams. The \code{WHERE} clause indicates the pattern of events that need to be matched in the stream. The pattern can be any \emph{unary} CEL expression \cite{formal-framework-cer}. In our query, the pattern \code{T as t1; T+ as ts} indicates that we want to capture all complex events that consist of an event type \code{T} followed by an arbitrary number of events of type \code{T}. In particular, the operator (;) indicates sequencing and the operator (+) indicates non-empty repeated sequencing. We want to remark that sequencing in CEL is non-contiguous. Consequently, the \code{T} events do not need to be contiguous --- there might be other events in between. The \code{FILTER} clause allows to filter events by unary predicates. The clause \code{PARTITION BY} allows to express correlation among events in the form of equi-joins. The \code{WITHIN} clause specifies the time-window. In our query, the time between the first event \code{T} and the last event \code{T} must be within 5 minutes. Finally, the \code{SELECT} clause allows to project the result.
\end{example}

Next, we give the formal syntax and semantics of CEQL.

\textbf{Events, complex events, and valuations}. Fix a set of \emph{event types} \textbf{T} (e.g., \code{H} and \code{T}), a set of \emph{attribute names} \textbf{A} (e.g., $id$, and $val$), and a set of \emph{data values} \textbf{D} (e.g., integer values, string values, etc.). A \emph{data-tuple t} is a partial mapping that maps attribute names from \textbf{A} to data values in \textbf{D}. Each data-tuple is associated to an event type. We denote $t(a) \in \textbf{D}$ the value of the attribute $a \in \textbf{A}$ assigned by $t$, and $t(type) \in \textbf{T}$ the event type of $t$. If $t$ is not defined on attribute $a$, then we write $t(a) = \text{NULL}$.

A \emph{stream} is a possibly infinite sequence $S = t_{0}t_{1}t_{2}\ldots$ of data-tuples. Given a set $D \subseteq \mathbb{N}$, we define the set of data tuples $S[D] = \{ t_{i} \ | \ i \in D\}$. A \emph{complex event} is a pair $C = ([i,j], D)$ where $i \le j \in \mathbb{N}$ and $D$ is a subset of $\{i, \ldots, j\}$. Intuitively, given a stream $S = t_{0}t_{1}\ldots$ the interval $[i, j]$ of $C$ represents the subsequence $t_{i}t_{i+1} \ldots t_{j}$ of $S$ where the complex event $C$ happens and $S[D]$ represents the data-tuples from $S$ that are relevant for $C$. We write $C(data)$ to denote $D$, $C(time)$ to denote the time-interval $[i, j]$, and $C(start)$ and $C(end)$ for $i$ and $j$, respectively.

Let \textbf{X} be a set of \emph{variables}, which includes all event types, $\textbf{T} \subseteq \textbf{X}$. A \emph{valuation} is a pair $V = ([i, j], \mu)$ with $[i,j]$ a time interval as above and $\mu$ a mapping that assigns subsets of $\{i, \ldots, j\}$ to variables in \textbf{X}. We write $V(time)$, $V(start)$, and $V(end)$ for $[i,j]$, $i$, and $j$, respectively, and $V(X)$ for the subset of $\{i,\ldots, j\}$ assigned to X by $\mu$.

We write $C_{V}$ for the complex event that is obtained from valuation $V$ by forgetting the variables in $V$: $C_{V}(time) = V(time)$ and $C_{V}(data) = \bigcup\limits_{X \in \textbf{X}} V(X)$. The semantics of CEQL will be defined in terms of valuations, which are subsequently transformed into complex events as explained.

\textbf{Predicates}. A (unary) \emph{predicate} is a possibly infinite set $P$ of data-tuples. A data-tuple $t$ \emph{satisfies} predicate $P$, denote $t \Vdash P$, if, and only if, $t \in P$. We generalize this definition from data-tuples to sets by taking a ``for all'' extension: a set of data-tuples $T$ satisfies $P$, denoted by $T \Vdash P$, if, and only if, $\displaystyle\mathop{\forall}_{t \in T} t \vDash P$.
\todo[inline]{Un predicat es defineix com un conjunt de data-tuples?}

\textbf{Syntax}. The abstract syntax of CEQL is as follows:

\begin{figure}[H]
  \begin{minted}[xleftmargin=0pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT        [selection strategy] <list of variables>
    FROM          <list of streams>
    WHERE         <CEL formula>
    (PARTITION BY <list of attributes>)?
    (WHITHIN      <time>)?
  \end{minted}
\end{figure}

\vspace{-30pt}
We remark that CEL includes \code{FILTER}, and so CEQL does not need a separate \code{FILTER} clause. The \code{WHERE} clause expects a pattern written in Complex Event Logic (CEL) \cite{formal-framework-cer}, whose abstract syntax is represented by the following grammar:

\vspace{-20pt}
\begin{equation*}
  \varphi := R    \ | \ \varphi \ \text{AS} \ X    \ | \    \varphi \ \text{FILTER} \ X[P]  \ | \   \varphi \ \text{OR} \ \varphi   \ | \  \varphi ; \varphi    \ | \  \varphi+ \ | \ \pi_{L}(\varphi).
\end{equation*}

\vspace{-10pt}
In this grammar, $R$ is an event type in \textbf{T}, $X$ is a variable in \textbf{X}, $P$ is a predicate, and $L$ is a subset of variables in \textbf{X}.

\textbf{Semantics}. The semantics of CEQL is as follows. A CEQL query first evaluates its \code{FROM} clause, then its \code{PARTITION BY} clause, and subsequently its \code{WHERE, SELECT, WITHIN} clauses, in that order. The \code{FROM} clause specifies the list of streams. All these streams are logically merged into a single stream $S$. The optional \code{PARTITION BY} clause logically partitions this stream into multiple substreams $S_{1}, S_{2}\ldots$ and executes the \code{WHERE-SELECT-WITHIN} clauses on each substream. The union of the outputs generated for each substream constitute the final output. Note, the different streams could be evaluated in parallel. CEQL's \code{WHERE} and \code{FILTER} clause are derived from the semantics of CEL in Figure~\ref{fig:cel:semantics}. Specifically, given a stream $S = t_{0}t_{1}t_{2} \ldots $, a CEL formula $\varphi$ evaluates to a set of valuations, denoted $\InSBrackets{\varphi}(S)$. The base case is when $\varphi$ is an event type $R$. In that case $\InSBrackets{\varphi}(S)$ contains all valuations whose time-interval is a single position $i$, such that the data-tuple $t_{i}$ at position $i$ in $S$ is of type $R$. The \code{AS} clause is a variable assignment that takes an existing valuation $V \in \InSBrackets{\varphi}(S)$ and extends it by gathering all positions $\bigcup_{Y}V(Y)$ in variable $X$, keeping all other variables as in $V$. The \code{FILTER} $X[P]$ clause retains only those valuations for which the content of variables $X$ satisfies predicate $P$. The \code{OR} clause takes the union of two sets of valuations. The sequencing operator ($\varphi;\varphi$) uses the time-interval for capturing all pairs of valuations in which the first is chronologically followed by the second. The semantics of iteration ($\varphi+$) is defined as the application of sequencing ($;$) one or more times over the same formula $\varphi$. The projection $\pi_{L}$ modifies valuations by setting all variables that are not in $L$ to empty. Hence, \code{WHERE-FILTER} return a set of valuations when evaluated over a stream. The \code{SELECT} clause, if it does not mention a selection strategy (explained later), corresponds to a projection in CEL. Finally, if $\epsilon$ is a time-interval, then the \code{WITHIN} clause operate on the resulting set of valuations $\InSBrackets{\varphi \ \text{WITHIN} \ \epsilon}(S) = \{ V \in \InSBrackets{S} \ | \ V(end) - V(start) \le \epsilon \}$.

\begin{figure}[t]
  \begin{align*}
    \InSBrackets{R}(S) &= \{V \ | \ V(time) = [i,i] \land t_{i}(type) = R\\
                       &\qquad\quad \land V(R) = {i} \land \forall X \ne R. V(X) = \emptyset \}\\
    \InSBrackets{\varphi \ \text{AS} \ X}(S) &= \{V \ | \ \exists V' \in \InSBrackets{\varphi}(S). V(time) = V'(time)\\
                       &\qquad\quad \land V(X) = \cup_{Y} V'(Y)\\
                       &\qquad\quad \land \forall Z \ne X. V(Z) = V'(Z)\}\\
    \InSBrackets{\varphi \ \text{FILTER} \ X[P]}(S) &= \{V \ | \ V \in \InSBrackets{\varphi}(S) \land V(X) \vDash P \}\\
    \InSBrackets{\varphi_{1} \ \text{OR} \ \varphi_{2}}(S) &= \InSBrackets{\varphi_{1}}(S) \cup \InSBrackets{\varphi_{2}}(S)\\
    \InSBrackets{\varphi_{1} \ ; \ \varphi_{2}}(S) &= \{V \ | \ \exists V_{1} \in \InSBrackets{\varphi_{1}}(S), V_{1} \in \InSBrackets{\varphi_{2}}(S).\\
                       &\qquad\quad  V_{1}(end) = V_{2}(start)\\
                       &\qquad\quad \land V(time) = [V_{1}(start), V_{2}(end)]\\
                       &\qquad\quad \land \forall X. V(X) = V_{1}(X) \cup V_{2}(X) \}\\
    \InSBrackets{\varphi+}(S) &= \InSBrackets{\varphi}(S) \cup \InSBrackets{\varphi;\varphi+}(S)\\
    \InSBrackets{\pi_{L}(\varphi)}(S) &= \{ V \ | \ \exists V' \in \InSBrackets{\varphi}(S). V(time) = V'(time)\\
                              &\qquad\quad \forall X \in L. V(X) = V'(X) \\
                              &\qquad\quad \forall X \notin L. V(X) = \emptyset \}
  \end{align*}
  \caption{The semantics of CEL.}
  \label{fig:cel:semantics}
\end{figure}

\textbf{Complex event semantics}. The complex event semantics of CEL and CEQL is obtained by first evaluating the query under the valuations semantics, and then removing variables. That is, if $\varphi$ is a CEL formula or CEQL query, its complex event semantics $\InDBrackets{\varphi}(S)$ is defined $\InDBrackets{\varphi}(S) := \{ C_{V} \ | \ V \in \InSBrackets{\varphi}(S)\}$.

\section{Selection strategies}\label{sec:selection_strategies}

\emph{Selection strategies} (or \emph{selectors}) are unary operators over CEL formulas that restrict the set of results and speed up query processing. We present four selection strategies \cite{formal-framework-cep,formal-framework-cer}: \emph{strict} (\textsc{strict}), \emph{next} (\textsc{nxt}), \emph{last} (\textsc{last}) and \emph{max} (\textsc{max}). \textsc{strict} and \textsc{nxt} are motivated by the \emph{strict-contiguity} and \emph{skip-till-next-match} selector strategies proposed by SASE \cite{sase}, while \textsc{last} and \textsc{max} are useful selection strategies from a semantic viewpoint \cite{formal-framework-cer}. Next, we describe and formally specify selection strategy \textsc{max}, as it is relevant in our work, and refer the interested reader to \cite{formal-framework-cer} for a definition and discussion of the other selection strategies. For the sake of the discussion, we will define the \emph{support} of a valuation $V$ as the set of all positions appearing in the range of $V$, i.e., $sup(V) = \bigcup\limits_{X \in \textbf{X}}V(X)$.

\textsc{MAX}. This selection strategy keeps the maximal complex events in terms of set inclusion, which could be naturally more useful because these complex events are the \emph{most informative}. Formally, given a CEL formula $\varphi$ we say that $V \in \InSBrackets{\textsc{max}(\varphi)}(S)$ holds iff $V \in \InSBrackets{\varphi}(S)$ and for all $V' \in \InSBrackets{\varphi}(S)$, if $sup(V) \subseteq sup(V')$, then $sup(V) = sup(V')$ (i.e., $V$ is maximal with respect to set containment). For example, given a CEL query $\varphi$, if $\InSBrackets{\varphi}(S)$ returns $\{ 3,6,7\}$, $\{3,4,7\}$, and $\{3,4,6,7\}$. Then, $\textsc{max}(\varphi)$ will only return $\{ 3, 4, 6, 7\}$, which is the maximal complex event.

\section{Computational model}\label{sec:cea}

As explained in Section~\ref{sec:ceql}, evaluating a CEQL query corresponds to evaluating the query's \code{SELECT-WHERE-WITHIN} clauses on either a single stream, or multiple different substreams. In our work, the \code{SELECT-WHERE} part of a query is compiled into a \emph{Complex Event Automaton} \cite{formal-framework-cep,formal-framework-cer}, which is a form of finite automaton that produces complex events. Our evaluation algorithm is then defined in terms of CEA: it takes as input a CEA $\mathcal{A}$, the time-window $\epsilon$ specified in the \code{WITHIN} clause, and a stream $S$, and uses this to compute $\InDBrackets{\varphi}(S)$.

\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \centering
    \inputtikz{cea}
    \vspace*{2em}
  \end{subfigure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \inputtikz{stream}
  \end{subfigure}

  \caption{A CEA representing the query from Figure~\ref{fig:query:2} and an example of stream.}
  \label{fig:cea}
\end{figure}

\begin{example}
  In Figure~\ref{fig:cea} we show the compilation of the query from Figure~\ref{fig:query:2} into an equivalent CEA $\mathcal{A}$. We depict predicates by listing, in array notation, the event type, and the constraint on the temperature attribute. The initial state is $q_{1}$ and there is only one final state: $q_{4}$. The figure also includes an example stream $S$, where the values correspond to the event type, the identifier attribute, and the temperature attribute, in that order.
\end{example}

Formally, a \emph{Complex Event Automaton (CEA)} is a tuple $\mathcal{A} = (Q, \Delta, q_{0}, F)$ where $Q$ is a finite set of states, $\Delta \subseteq Q \times \textbf{P} \times \{\bullet, \circ\} \times (Q \setminus \{ q_{0} \})$ is a finite transition, $q_{0} \in Q$ is the initial state, and $F \subseteq Q$ is the set of final states. We will denote transitions in $\Delta$ by $q \xrightarrow[]{P/m} q'$. A \emph{run} of $\mathcal{A}$ over stream $S$ from positions $i$ to $j$ is a sequence $\rho := q_{i} \xrightarrow[]{P_{i}/m_{i}} q_{i+1} \xrightarrow[]{P_{i+1}/m_{i+1}} \ldots \xrightarrow[]{P_{j}/m_{j}} q_{j+1}$ such that $q_{i}$ is the initial state of $\mathcal{A}$ and for every $k \in [i,j]$ it holds that $q_{k} \xrightarrow[]{P_{k}/m_{k}} q_{k+1} \in \Delta$ and $t_{k} \vDash P_{k}$. A run $\rho$ is \emph{accepting} if $q_{j+1} \in F$. An accepting run of $\mathcal{A}$ over $S$ from $i$ to $j$ naturally defines the complex event $C_{\rho} := ([i, j], \{ k \ | \ i \le k \le j \land m_{k} = \bullet \})$. Finally, we define the semantics of $\mathcal{A}$ over a stream $S$ as $\InDBrackets{\mathcal{A}}(S) := \{ C_{\rho} \ | \ \rho \text{ is an accepting run of } \mathcal{A} \text{ over } S\}$.

The usefulness of CEA comes from the fact that CEL cab be translated into CEA \cite{formal-framework-cep,formal-framework-cer}. Because the \code{SELECT-WHERE} part of a CEQL query is in essence a CEL formula, this reduces the evaluation problem of the \code{SELECT-WHERE-WITHIN} part of CEQL query into the evaluation problem for CEA.

\begin{theorem}[Theorem~1 \cite{core}]\label{theorem:cea}
  For every CEL formula $\varphi$ we can construct a CEA $\mathcal{A}$ of size linear in $\varphi$ such that for every $\epsilon$:
  \begin{equation*}
    \InDBrackets{\varphi \code{ WITHIN } \epsilon}(S) = \{ C \ | \ C \in \InDBrackets{\mathcal{A}}(S) \land C(end) - C(start) \le \epsilon \}
  \end{equation*}
\end{theorem}

Our evaluation algorithm will compute the right-hand side of this equation. It requires that the input CEA $\mathcal{A}$ is \emph{I/O deterministic}: for every pair of transitions $q \xrightarrow[]{P_{1}/m_{1}} q_{1}$ and $q \xrightarrow[]{P_{2}/m_{2}} q_{2}$ from the state $q$, if $P_{1} \cap P_{2} \ne \emptyset$ then $m_{1} \ne m_{2}$. To put it another way, an event $t$ may trigger both transitions at the same time only if one transition marks the event, but the other does not. In \cite{formal-framework-cep,formal-framework-cer}, it was shown that any CEA can be I/O-determinized, with a possibly exponential blow-up in the size of the automaton.

\todo[inline]{falta introduir l'enumeraci√≥ de complex events i la propietat de constant delay enumeration}