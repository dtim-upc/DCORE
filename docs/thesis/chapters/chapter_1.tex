\chapter{Introduction}\label{chapter:introduction}

\emph{Complex Event Recognition (CER)}, also called Complex Event Processing, refers to the activity of identifying, in streams of high-velocity continuously arriving primitive event data, collections of events that collectively satisfy some pattern.
These collections of events that satisfy some pattern are referred as \emph{complex events}. Conceptually, CER systems allow expressing patterns that match incoming events not only on the basis of their content, but also on where they occur in the input stream, and how this order relates to other events in the stream, in addition to other constraints between events. CER queries distinguish themselves from streaming queries supported by engines such as Flink \cite{flink}, or Spark \cite{spark} in that CER queries include \emph{regular expressions operators} like \emph{sequencing}, \emph{disjunction} and \emph{iteration} to express spatio-temporal constraints that are not supported by stream processing engines.

In recent years, CER has emerged as a prominent technology and has been successfully applied in scenarios like maritime monitoring \cite{maritime-monitoring}, network intrusion detection \cite{network-intrusion-detection}, industrial control systems \cite{industrial-control}, and real-time analytics \cite{real-time-analytics}. Prominent examples of CER systems from academia and industry include Cayuga \cite{cayuga}, CORE \cite{core}, Esper \cite{esper}, SASE \cite{sase}, and TESLA \cite{tesla}, among others (see surveys \cite{survey-systems-1,survey-systems-2}).  All such systems share the common goal of providing timely reaction to situations of interest in a real-time manner. Thus, having query evaluation mechanisms that minimize latency is a shared desiderata. Nonetheless, the evaluation of CER queries is well known to be computationally expensive. Indeed, such evaluation requires the maintenance of a set of partial matches which grows \textit{super-linearly} in the number of processed events. We illustrate this problem with an example as follows.

\begin{example}
Consider a stream produced by wireless sensors placed in a warehouse, whose main objective is to detect fires. We assume each sensor can measure both temperature (in Celsius degrees) and relative humidity (as a percentage). Additionally, each sensor is assigned a unique id corresponding to the zone of the warehouse where the sensor is located. The \emph{events} produced by the sensors are composed of the id of the sensor and a measurement corresponding to temperature or relative humidity. We write $T(id, val)$ for an event reporting temperature $val$ from sensor $id$, and $H(id, val)$ for an event reporting humidity $val$ from sensor $id$. An excerpt of the stream of events, indexed by order of arrival, is depicted in Figure~\ref{fig:stream}.

\begin{figure}[H]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c}\hline
    type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
    id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
    val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
    timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
  \end{tabular}
  \caption{Exemplary stream of events measuring temperature ($T$) and relative humidity ($H$)}
  \label{fig:stream}
\end{figure}

For the sake of illustration, assume that it has been detected that when the temperature of a storage room increases from below 30 celsius degrees to above 40 celsius degrees and the humidity is below 25\% there is a high probability of fire. The following query retrieves the id of the zone where the fire might be originated so the notification system could warn the security team.

\begin{figure}[h!]
  \begin{minted}[xleftmargin=100pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT t2.id FROM warehouse
    WHERE (T as t1; H as h1; T as t2)
    FILTER t1[val < 30] AND h1[val < 25]
      AND t2[val > 40] AND t1[id] = h1[id]
      AND h1[id] = t2[id]
    WITHIN 10 events
  \end{minted}
  \caption{CEQL query on a wireless sensors network stream, which goal is to detect fires.}
  \label{fig:query:1}
\end{figure}

When the query from Figure~\ref{fig:query:1} is applied to the input stream from Figure~\ref{fig:stream}, the resulting complex events are: $\{ 1, 3, 7 \}$, $\{ 1, 6, 7 \}$, $\{ 1, 3, 6, 7 \}$, $\{ 1, 3, 8 \}$, $\{ 1, 6, 8 \}$, $\{ 1, 3, 6, 8 \}$, $\{ 1, 3, 7, 8\}$, $\{ 1, 6, 7, 8\}$, and $\{ 1, 3, 6, 7, 8\}$. Observe that, within a given time window, the number of \emph{partial matches} that consist of a temperature measurement followed by a humidity measurement followed by a temperature measurement may easily be cubic in the number of events in the window.
\end{example}

In order to overcome the issues illustrated by the example above, current CER engines either materialize, or lazily compute this set of partial matches to be able to quickly determine when a temperature measurement constitute an answer to this query. In either case, an $\Omega(N^{3})$ operation is required to complete the processing of the complex event, where $N$ is the number of previous events seen within the sliding window. This gets worsened under the default \emph{skip-till-any-match} \cite{skip-till-any-match} policy, where queries that include the iterator operator may have sets of partial matches that grow \emph{exponentially} in $N$ \cite{core}.  Given the computational challenges of CER query evaluation, there has been ongoing research on this field \cite{research-evaluation-query, formal-framework-cer}, where a wide range of different execution models has been proposed \cite{survey-systems-1, survey-systems-2}. Although, all of these system still suffer from overhead super-linear in the size of the stream, and thus their scalability is limited to queries over short time windows.

An attempt to overcome the detrimental super-linear complexity of contemporary CER systems is the \emph{COmplex event Recognition Engine (CORE)} engine \cite{core}. Such engine builds on top of a \emph{rigorous} and \emph{efficient} framework for CER \cite{formal-framework-cep, formal-framework-cer}. To do so, it employs a formal language for specifying complex events, called \emph{CEQL}, that contains many features used in the literature including time windows as well as a partition-by event correlation operator \cite{on-the-expressiveness, core}. Such language can be compiled into a \emph{formal computational model} called \emph{complex event automata (CEA)}, which includes the evaluation of unary filter predicates. CORE incorporates efficient algorithms for evaluating CEA over event streams using constant time, under data complexity, per event followed by output-linear delay enumeration of the complex events, which are not affected by the length of the stream, size of the query, or size of the time window \cite{formal-framework-cer, core}.

Despite all previous accomplishments, there is still room for improvement. First, CEQL has to be restricted to unary predicates to be able to translate it into an equivalent CEA. Unary CEQL and CEA are expressively equivalent, however, incomparable when equipped with $n$-ary predicates, with $n > 1$ (e.g., the evaluation of predicates of the kind \texttt{t1[id] = h1[id]}). In particular, when CEQL is restricted to binary predicates, it is strictly more expressive than CEA \cite{on-the-expressiveness}. Secondly, CORE's evaluation algorithm guarantees constant update time per event, under data complexity, and, once a match is found, the results are materialized from the data structure and enumerated with output-linear delay, however, when a query includes an iteration, the set of partial matches may grow exponentially in the size of the stream, resulting in an exponential cost of enumerating the complex events.

In this thesis, we embark on the task of extending CORE to support the evaluation of non-unary predicates while maintaining the performance guarantees, and reduce the time complexity of the enumeration phase of the evaluation algorithm. To do so, we propose a novel parallel enumeration algorithm that allows to partition the workload of enumerating candidate complex events and evaluating $n$-ary predicates over a set of workers. We theoretically show the soundness of the approach, and demonstrate its practical superiority with respect to CORE's built-in evaluation algorithm as well as state of the art partitioning strategies.

\textbf{Note.} Throughout the development of this thesis, several new publications on the area have been published \cite{formal-framework-cer, core}, which have impacted the results of this work.

\section{Contributions}
\label{sec:contribution}

Our contributions are as follows:

\begin{enumerate}[label=(\roman*)]
  \item A novel evaluation algorithm for CEA. Our algorithm is based on CORE's main evaluation algorithm \cite{core}. The proposed algorithm tackles the exponential complexity of the enumeration phase by distributing the workload on independent asynchronous processes that cooperatively enumerate the set of complex events. Our work includes a proof of correctness of this algorithm.

  \item A distributed system for evaluating non-unary predicates over CEQL queries. The CEQL query is fed into the system and processed by a single actor. This actor parses the query, analyses its semantics, and generates the corresponding unary CEQL, and an evaluation plan for the non-unary predicates. The unary CEQL is processed sequentially using the efficient evaluation process of \cite{formal-framework-cep} and complex events are output. Then, a \emph{distribution strategy} is used to distribute the complex events, with additional non-unary predicate information, between the nodes of the distributed system. Finally, each node of the system, evaluates the non-unary predicates over the resulting complex events.   Furthermore, we propose different distributions strategies and analyse their behaviour.

  \item Another distributed system for evaluating non-unary predicates over CEQL queries based on the distributed evaluation algorithm presented in Contribution~(I). The system differs from the previous in that: the query is feed to \emph{all} the nodes, each node parses and extracts the corresponding unary CEQL query and a plan for evaluating the non-unary predicates of the query, and the evaluation algorithm is executed on each node. During the distributed enumeration phase of the evaluation algorithm, the output is filtered taking into account the non-unary predicates.

  \item We show that our distributed systems are practical. We experimentally compare both systems against themselves, and equivalent sequential implementations. Our experiments show that both systems outperform sequential implementations, and that the second distributed system based on Contributions~(I) outperforms our first implementation based on \cite{formal-framework-cep}.
\end{enumerate}

\section{Outline}
\label{sec:outline}

The document is organised as follows. We discuss related work in Chapter~\ref{chapter:related_work}. We give an introduction to CEQL and describe how CEQL is compiled into an equivalent CEA in Chapter~\ref{chapter:preliminaries}. In Chapter~\ref{chapter:algorithm} we present the distributed evaluation algorithm. We introduce several distribution strategies on Chapter~\ref{chapter:non-unary-predicates}. We discuss the implementation of both distributed systems in Chapter~\ref{chapter:implementation}. We dedicate Chapter~\ref{chapter:experimental_evaluation} to the empirical experiments. We present our conclusions and future work on Chapter~\ref{chapter:conclusion}.
