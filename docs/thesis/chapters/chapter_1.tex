\chapter{Introduction}\label{chapter:introduction}

\emph{Complex Event Recognition (CER)}, also called Complex Event Processing, refers to the activity of identifying, in streams of high-velocity continuously arriving primitive event data, collections of events that collectively satisfy some pattern.
These collections of events that satisfy some pattern are referred as \emph{complex events}. Conceptually, CER systems allow expressing patterns that match incoming events not only on the basis of their content, but also on where they occur in the input stream, and how this order relates to other events in the stream, in addition to other constraints between events. CER queries distinguish themselves from streaming queries supported by engines such as Flink \cite{flink}, or Spark \cite{spark} in that CER queries include \emph{regular expressions operators} like \emph{sequencing}, \emph{disjunction} and \emph{iteration} to express spatio-temporal constraints that are not supported by stream processing engines.

In recent years, CER has emerged as a prominent technology and has been successfully applied in scenarios like maritime monitoring \cite{maritime-monitoring}, network intrusion detection \cite{network-intrusion-detection}, industrial control systems \cite{industrial-control}, and real-time analytics \cite{real-time-analytics}. Prominent examples of CER systems from academia and industry include Cayuga \cite{cayuga}, CORE \cite{core}, Esper \cite{esper}, SASE \cite{sase}, and TESLA \cite{tesla}, among others (see surveys \cite{survey-systems-1,survey-systems-2}).

CER systems aim to detect situations of interest, in the form of complex events, with the goal of providing insightful information and reactive responses. As such, they strive for low latency query evaluation. CER query evaluation, however, is known to be \emph{computationally challenging}. In practise, evaluating a CER query requires maintaining a set of partial matches, and this set quickly grows \emph{super-linearly} in the number of events processed. We illustrate this problem with the following example.

\textbf{Example 1}. Consider that we have a stream produced by wireless sensors placed in a warehouse, whose main objective is to detect fires. Suppose that each sensor can measure both temperature (in Celsius degrees) and relative humidity (as a percentage). Each sensor is assigned a unique id corresponding to the zone of the warehouse where the sensor is located. The \emph{events} produced by the sensors are composed of the id of the sensor and the a measurement of temperate or relative humidity. We write $T(id, tmp)$ for an event reporting temperature $tmp$ from sensor $id$, and $T(id, hum)$ for an event reporting humidity $hum$ from sensor $id$. For the sake of illustration, assume that it has been detected that when the temperature of a storage room increases from below 30 celsius degrees to above 40 celsius degrees and the humidity is below 25 \% there is a high probability of fire. The following query retrieves the id of the zone where the fire might be originated so the notification system could warn the security team.

\begin{figure}[H]
  \begin{minted}[xleftmargin=100pt, linenos=false, fontsize=\scriptsize]{text}
    SELECT t2.id FROM warehouse
    WHERE (T as t1; H as h1; T as t2)
    FILTER t1[temp < 30] AND h1[hum < 25]
      AND t2[temp > 40] AND t1[id] = h1[id]
      AND h1[id] = t2[id]
    WITHIN 10 minutes
  \end{minted}
\end{figure}

\vspace{-30pt}
Notice that, within a given time window, the number of \emph{partial matches} that consist of a temperature measurement followed by a humidity measurement followed by a temperature measurement may easily be cubic in the number of events in the window. Current CER engines either materialize, or lazily compute this set of partial matches to be able to quickly determine when a temperature measurement constitute an answer to this query. In either case, an $\Omega(N^{3})$ operation is required to complete the processing of the complex event, where $N$ is the number of previous events seen within the sliding window. Even worse, under the default \emph{skip-till-any-match} \cite{skip-till-any-match} policy, queries that include the iterator operator may have sets of partial matches that grow \emph{exponentially} in $N$ \cite{core}.

Given the computational challenges of CER query evaluation, there has been ongoing research on this field \cite{research-evaluation-query, formal-framework-cer}. A wide range of different execution models has been proposed \cite{survey-systems-1, survey-systems-2}. A myriad of optimization techniques have proposed such as restricting the output set using event selection policies \cite{skip-till-any-match} that somewhat limit the super-linear complexity. Although, all of these system still suffer from overhead super-linear in the size of the stream. The scalability of this system is limited to CER queries over a short window (see Section~6 \cite{core}). Unfortunately, some applications like maritime monitoring \cite{maritime-monitoring} or credit card fraud detection \cite{fraud-detection} require long time windows.

In recent years, to overcome the detrimental super-linear complexity of CER system, Vansummeren~\textit{et al.} embarked on the task of giving a \emph{rigorous} and \emph{efficient} framework to CER \cite{formal-framework-cep, formal-framework-cer}. They proposed a formal language for specifying complex events, called \emph{CEQL}, that contains many features used in the literature including time windows as well as a partition-by event correlation operator \cite{on-the-expressiveness, core}. They introduced a \emph{formal computational model} for CER, called \emph{complex event automata (CEA)}, and studied how to compile CEQL formulas with unary filters into CEA \cite{formal-framework-cer}. They provided efficient algorithms for evaluating CEA over event streams using constant time, under data complexity, per event followed by output-linear delay enumeration of the complex events, which are not affected by the length of the stream, size of the query, or size of the time window \cite{formal-framework-cer, core}. And, implemented such system, called \emph{COmplex event Recognition Engine (CORE)}, which outperforms the other systems by up to three orders of magnitude on different query workloads \cite{core}.

Despite all previous accomplishments, there is still room for improvement. First, CEQL has to be restricted to unary predicates to be able to translate it into an equivalent CEA. Unary CEQL and CEA are expressively equivalent, however, incomparable when equipped with $n$-ary predicates, with $n > 1$. In particular, when CEQL is restricted to binary predicates, it is strictly more expressive than CEA \cite{on-the-expressiveness}. Secondly, CORE's evaluation algorithm guarantees constant update time per event, under data complexity, and, once a match is found, the results are materialized from the data structure and enumerated with output-linear delay, however, when a query includes an iteration, the set of partial matches may grow exponentially in the size of the stream, resulting in an exponential cost of enumerating the complex events.

In this thesis, we embark on the task of extending CORE to support the evaluation of non-unary predicates while maintaining the performance guarantees, and reduce the time complexity of the enumeration phase of the evaluation algorithm.

We remark that, throughout the development of this thesis, several new publications on the field of CER has been release \cite{formal-framework-cer, core}, which have impacted the results of this work. In particular, we started this thesis focusing on the evaluation of non-unary predicates, and later on reducing the complexity of the enumeration phase of the evaluation algorithm. The former is based on the work of \cite{formal-framework-cep, on-the-expressiveness}, and the later on the most recent work of \cite{formal-framework-cer, core}. We emphasize that both works present similar results: a formal language for CER, an automata-based computational model, and a theoretical evaluation algorithm that requires only constant time per event, followed by output-linear delay enumeration of the output. But, the later has a more solid theoretical background, rigorous proofs, a simpler and more elegant evaluation algorithm, and publicly available implementation (see \cite{core-repo}).

\section{Contribution}
\label{sec:contribution}



\section{Document overview}
\label{sec:document_overview}
