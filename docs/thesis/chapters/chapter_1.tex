\chapter{Introduction}\label{chapter:introduction}

\emph{Complex Event Recognition (CER)}, also called Complex Event Processing, refers to the activity of identifying, in streams of high-velocity continuously arriving primitive event data, collections of events that collectively satisfy some pattern.
These collections of events that satisfy some pattern are referred as \emph{complex events}. Conceptually, CER systems allow expressing patterns that match incoming events not only on the basis of their content, but also on where they occur in the input stream, and how this order relates to other events in the stream, in addition to other constraints between events. CER queries distinguish themselves from streaming queries supported by engines such as Flink \cite{flink}, or Spark \cite{spark} in that CER queries include \emph{regular expressions operators} like \emph{sequencing}, \emph{disjunction} and \emph{iteration} to express spatio-temporal constraints that are not supported by stream processing engines.

In recent years, CER has emerged as a prominent technology. It has been successfully applied in scenarios like maritime monitoring \cite{maritime-monitoring}, network intrusion detection \cite{network-intrusion-detection}, industrial control systems \cite{industrial-control}, and real-time analytics \cite{real-time-analytics}. Prominent examples of CER systems from academia and industry include Cayuga \cite{cayuga}, CORE \cite{core}, Esper \cite{esper}, SASE \cite{sase}, and TESLA \cite{tesla}, among others (see surveys \cite{survey-systems-1,survey-systems-2}).  All such systems share the common goal of providing timely reaction to situations of interest in a real-time manner. Thus, having query evaluation mechanisms that minimize latency is a shared desiderata. Nonetheless, the evaluation of CER queries is well-known to be computationally expensive. Indeed, such evaluation requires the maintenance of a set of partial matches which grows \textit{super-linearly} in the number of processed events. We illustrate this problem with an example as follows.

\begin{example}\label{example:1}
Consider a stream produced by wireless sensors placed in a warehouse, whose main objective is to detect fires. We assume each sensor can measure both temperature (in Celsius degrees) and relative humidity (as a percentage). Additionally, each sensor is assigned a id corresponding to the zone of the warehouse where the sensor is located. The \emph{events} produced by the sensors are composed of the id of the sensor and a measurement corresponding to temperature or relative humidity. We write $T(id, val)$ for an event reporting temperature $val$ from sensor $id$, and $H(id, val)$ for an event reporting humidity $val$ from sensor $id$. An excerpt of the stream of events, indexed by order of arrival, is depicted in Figure~\ref{fig:stream}.

\begin{figure}[H]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c}\hline
    type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
    id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
    val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
    timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
  \end{tabular}
  \caption{Exemplary stream of events measuring temperature ($T$) and relative humidity ($H$)}
  \label{fig:stream}
\end{figure}

For the sake of illustration, assume that it has been detected that when the temperature of a storage room increases from below 30 celsius degrees to above 40 celsius degrees and the humidity is below 25\% there is a high probability of fire. The following query retrieves the id of the zone where the fire might be originated so the notification system can warn the security team.

\begin{figure}[h!]
  \begin{minted}[xleftmargin=100pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT t2.id FROM warehouse
    WHERE (T as t1; H as h1; T as t2)
    FILTER t1[val < 30] AND h1[val < 25]
      AND t2[val > 40] AND t1[id] = h1[id]
      AND h1[id] = t2[id]
    WITHIN 10 events
  \end{minted}
  \caption{Query on a wireless sensors network stream, which goal is to detect fires.}
  \label{fig:query:1}
\end{figure}

When the query from Figure~\ref{fig:query:1} is applied to the input stream from Figure~\ref{fig:stream}, the resulting complex events are: $\{ 1, 3, 7 \}$, $\{ 1, 6, 7 \}$, $\{ 1, 3, 6, 7 \}$, $\{ 1, 3, 8 \}$, $\{ 1, 6, 8 \}$, $\{ 1, 3, 6, 8 \}$, $\{ 1, 3, 7, 8\}$, $\{ 1, 6, 7, 8\}$, and $\{ 1, 3, 6, 7, 8\}$. Observe that, within a given time window, the number of \emph{partial matches} that consist of a temperature measurement followed by a humidity measurement followed by a temperature measurement may easily be cubic in the number of events in the window.
\end{example}

In order to overcome the issues illustrated by Example~\ref{example:1}, current CER engines either materialize, or lazily compute the set of partial matches to be able to quickly determine when a temperature measurement constitute an answer to our query. In either case, an $\Omega(N^{3})$ operation is required to complete the processing of the complex event, where $N$ is the number of previous events seen within the sliding window. This gets worsened under the default \emph{skip-till-any-match} \cite{skip-till-any-match} policy, where queries that include the iterator operator may have sets of partial matches that grow \emph{exponentially} in $N$ \cite{core}.  Given the computational challenges of CER query evaluation, there has been ongoing research on this field \cite{research-evaluation-query, formal-framework-cer}, where a wide range of different execution models has been proposed \cite{survey-systems-1, survey-systems-2}. Although, all of these system still suffer from overhead super-linear in the size of the stream, and thus their scalability is limited to queries over short time windows.

An attempt to overcome the detrimental super-linear complexity of contemporary CER systems is the \emph{COmplex event Recognition Engine (CORE)} engine \cite{core}. Such engine builds on top of a \emph{rigorous} and \emph{efficient} framework for CER \cite{formal-framework-cep, formal-framework-cer}. To do so, it employs a formal language for specifying complex events, called \emph{CEQL}, that contains many features used in the literature including time windows as well as a partition-by event correlation operator \cite{on-the-expressiveness, core}. Such language can be compiled into a \emph{formal computational model} called \emph{complex event automata (CEA)}. CORE incorporates an efficient algorithm for evaluating CEA over event streams using constant time, under data complexity, per event followed by output-linear delay enumeration of the complex events, which is not affected by the length of the stream, size of the query, or size of the time window \cite{formal-framework-cer, core}.

One downside of CORE is that it is limited to unary filtering predicates. \cite{on-the-expressiveness} shows that unary CEL and CEA are expressively equivalent, however, incomparable when equipped with $n$-ary predicates (e.g., equi-joins like \code{t1[id] = h1[id]}). In particular, when CEL is restricted to binary predicates, it is strictly more expressive than CEA. As a result, CORE cannot guarantee optimal performance under non-unary predicates. Another downside is that in the presence of iterations (\emph{kleene star}), the set of partial matches may grow exponentially in the size of the stream, resulting in an exponential cost of enumerating the complex events.

In this thesis, we embark on the task of giving a new distributed framework for CER that deals with the limitations of many CER system to express and process complex predicates while preserving optimal performance.

\textbf{Note.} Throughout the development of this thesis, several new publications on the area have been published (e.g., \cite{formal-framework-cer, core}), which have impacted the results of this work.

\section{Contributions}
\label{sec:contribution}

Our contributions are as follows:

\begin{enumerate}[label=(\roman*)]
  \item We present a distributed framework for CER. This framework circumvents the filtering limitations of CORE while preserving optimal throughput. Based on this framework, we implemented two different architectures: DCERE and DCORE. DCORE uses the novel distributed evaluation algorithm for CER presented in this work.

  \item We present a novel distributed evaluation algorithm for CER. The proposed algorithm tackles (1) the super-linear complexity of non-unary predicates, and (2) the exponential complexity of the enumeration phase. Our work includes a proof of correctness of this algorithm.

  \item We show that our distributed framework is practical. Our experiments show that, in the presence of Big Data requirements, our distributed framework outperforms CORE on processing queries with complex predicates.
\end{enumerate}

\section{Outline}
\label{sec:outline}

The document is organised as follows. We discuss related work in Chapter~\ref{chapter:related_work}. We give an introduction to CEQL and describe how CEQL is compiled into CEA in Chapter~\ref{chapter:preliminaries}. We introduce the distributed CER framework on Chapter~\ref{chapter:distributed-cer}. In Chapter~\ref{chapter:algorithm} we present the novel distributed evaluation algorithm. We dedicate Chapter~\ref{chapter:experimental_evaluation} to the implementation of the framework and the experiments. We present our conclusions and future work on Chapter~\ref{chapter:conclusion}.
