\documentclass[xcolor=pdftex,dvipsnames,table]{beamer}

\mode<presentation>
{
  \usetheme{Madrid}
  \usecolortheme{seagull}
  \setbeamercovered{dynamic} %invisible,transparent,dynamic,highly dynamic
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}

\usepackage[english]{babel}

\usepackage{amsmath,amsfonts,amssymb,amscd,amsthm, bm, stmaryrd}

\usepackage{listings}
\usepackage[cache=false,section]{minted}


\usepackage{multirow}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{tikz}
\usetikzlibrary{external, automata, arrows.meta, positioning, calc}
\tikzexternalize[shell escape=-shell-escape,mode=graphics if exists, prefix=../thesis/tikz/cache/]
\newcommand{\inputtikz}[1]{%
  \tikzsetnextfilename{#1}%
  \input{../thesis/tikz/#1.tex}
}

\usepackage{graphicx}
\graphicspath{{../thesis/figures/}}

\usepackage{xcolor,colortbl}
\definecolor{Red}{rgb}{0.89, 0.0, 0.13}
\definecolor{Pink}{rgb}{1.0, 0.65, 0.79}
\definecolor{lightgreen}{rgb}{0.56, 0.93, 0.56}
\newcolumntype{a}{>{\columncolor{lightgreen}}c}
\newcolumntype{b}{>{\columncolor{Red}}c}

\newcommand{\code}[1]{\texttt{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% TITLE %%%%%%%%%%%%%%%%%

\title{Distributed Complex Event Recognition}
\subtitle{Master's Thesis}
\author{Arnau Abella}
\institute[UPC]{%
  {\tiny %
    \textit{Supervisors:}\\
    Sergi Nadal, Universitat Politècnica de Catalunya\\
    Stijn Vansummeren, UHasselt – Hasselt University\\
  }
  \vspace{10pt}
  \textrm{\scriptsize%
    Master in innovation and research in informatics\\
    \vspace{5pt}
    Facultat d’Informàtica de Barcelona (FIB)\\
    Universitat Politècnica de Catalunya (UPC)\\
  }
}
\date{\tiny \today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%

\AtBeginSection[]
{
  \begin{frame}<beamer>
      \frametitle{Table of Contents}
      \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\begin{frame}[fragile, allowframebreaks]{Complex Event Recognition}
  \begin{block}{\emph{Complex Event Recognition (CER)}}
    Identifying collections of events that collectively satisfy some pattern in high-velocity streams.
  \end{block}
  \framebreak
  \begin{example}
    A stream produced by wireless sensors placed in a warehouse, whose main objective is to detect fires.
    \begin{figure}[H]
      \centering
      \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c}\hline
        type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
        id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
        val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
        timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
      \end{tabular}
    \end{figure}
  \end{example}

  \begin{block}{}
    When the temperature of a storage room increases from below 30 celsius degrees to above 40 celsius degrees and the humidity is below 25\% there is a high probability of fire.
    \begin{figure}[H]
      \begin{minted}[xleftmargin=60pt, linenos=false, fontsize=\footnotesize]{text}
SELECT t2.id FROM warehouse
WHERE (T as t1; H as h1; T as t2)
FILTER t1[val < 30] AND h1[val < 25]
  AND t2[val > 40] AND t1[id] = h1[id]
  AND h1[id] = t2[id]
WITHIN 10 events
      \end{minted}
    \end{figure}
  \end{block}

 \begin{block}{}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=80pt, linenos=false, fontsize=\footnotesize]{text}
SELECT t2.id FROM warehouse
WHERE (T as t1; H as h1; T as t2)
FILTER t1[val < 30] AND h1[val < 25]
  AND t2[val > 40] AND t1[id] = h1[id]
  AND h1[id] = t2[id]
WITHIN 10 events
      \end{minted}
    \end{figure}
    \begin{figure}[H]
      \centering
      \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c}\hline
        type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
        id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
        val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
        timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
      \end{tabular}
    \end{figure}
 \end{block}

 \framebreak

 \begin{block}{}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=80pt, linenos=false, fontsize=\footnotesize]{text}
SELECT t2.id FROM warehouse
WHERE (T as t1; H as h1; T as t2)
FILTER t1[val < 30] AND h1[val < 25]
  AND t2[val > 40] AND t1[id] = h1[id]
  AND h1[id] = t2[id]
WITHIN 10 events
      \end{minted}
    \end{figure}
    \begin{figure}[H]
      \centering
      \begin{tabular}{|c|c|a|c|a|c|c|c|a|c|c}\hline
        type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
        id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
        val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
        timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
      \end{tabular}
    \end{figure}
 \end{block}

 \framebreak

 \begin{block}{}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=80pt, linenos=false, fontsize=\footnotesize]{text}
SELECT t2.id FROM warehouse
WHERE (T as t1; H as h1; T as t2)
FILTER t1[val < 30] AND h1[val < 25]
  AND t2[val > 40] AND t1[id] = h1[id]
  AND h1[id] = t2[id]
WITHIN 10 events
      \end{minted}
    \end{figure}
    \begin{figure}[H]
      \centering
      \begin{tabular}{|c|c|a|c|c|c|c|a|a|c|c}\hline
        type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
        id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
        val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
        timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
      \end{tabular}
    \end{figure}
 \end{block}

 \framebreak

 \begin{block}{}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=80pt, linenos=false, fontsize=\footnotesize]{text}
SELECT t2.id FROM warehouse
WHERE (T as t1; H as h1; T as t2)
FILTER t1[val < 30] AND h1[val < 25]
  AND t2[val > 40] AND t1[id] = h1[id]
  AND h1[id] = t2[id]
WITHIN 10 events
      \end{minted}
    \end{figure}
    \begin{figure}[H]
      \centering
      \begin{tabular}{|c|c|a|c|a|c|c|c|c|a|c}\hline
        type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
        id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
        val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
        timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
      \end{tabular}
    \end{figure}
 \end{block}

 \framebreak

 \begin{block}{}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=80pt, linenos=false, fontsize=\footnotesize]{text}
SELECT t2.id FROM warehouse
WHERE (T as t1; H as h1; T as t2)
FILTER t1[val < 30] AND h1[val < 25]
  AND t2[val > 40] AND t1[id] = h1[id]
  AND h1[id] = t2[id]
WITHIN 10 events
      \end{minted}
    \end{figure}
    \begin{figure}[H]
      \centering
      \begin{tabular}{|c|c|a|c|c|c|c|a|c|a|c}\hline
        type  &$H$&$T$&$H$&$H$&$T$&$H$&$H$&$T$&$T$ & \ldots \\ \hline
        id  & 1 & 1 & 2 & 1 & 2 & 2 & 1 & 1 & 1 & \multirow{2}{*}{\ldots} \\
        val & 50 & 24& 49& 24& 24& 42& 23& 40& 45\\ \hline
        timestamp & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \ldots \\ \hline
      \end{tabular}
    \end{figure}
 \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Partial Matches Problem}
 \begin{block}<1->{}
   Problem:
   \begin{itemize}
     \item<1-> $\Omega(N^{3})$ operation is required to complete the processing of the complex event.
     \item<2-> Under the default \emph{skip-till-any-match} \cite{skip-till-any-match} policy, the set of partial matches grow \emph{exponentially} in $N$.
   \end{itemize}
 \end{block}
 \begin{block}<3->{}
   Given the computational challenges of CER query evaluation, there has been ongoing research on this field.
 \end{block}
 \begin{block}<4->{}
   All of these system still suffer from:
   \begin{itemize}
     \item<4-> Overhead \emph{super-linear} in the size of the stream.
     \item<5-> Scalability is limited to queries over short time windows.
   \end{itemize}
 \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{CORE}
  \begin{block}{}
   \emph{COmplex event Recognition Engine (CORE)\cite{core}}:
   \begin{itemize}
     \pause
     \item \emph{Complex Event Logic (CEL)}
     \pause
     \item \emph{Complex Event Query Language (CEQL)}
     \pause
     \item \emph{Complex Event Automaton (CEA)}
     \pause
     \item CORE's evaluation algorithm, under \emph{data complexity}:
      \begin{itemize}
        \pause
        \item Update in constant time per input.
        \pause
        \item \emph{Output-linear delay} enumeration.
      \end{itemize}
   \end{itemize}
 \end{block}
\end{frame}

\begin{frame}{CORE}
  \begin{block}{}
    Downsides of CORE:
   \begin{enumerate}
     \pause
     \item Limited to \emph{unary} predicates.
     \pause
     \item The enumeration may be exponential in cost.
   \end{enumerate}
 \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Contributions}
  \begin{block}{}
   \begin{itemize}
     \item A distributed framework for CER that circumvents the filtering limitations of many CER systems.
      \begin{itemize}
        \pause
        \item Distributed CER Engine (DCERE)
        \pause
        \item Distributed CORE (DCORE)
      \end{itemize}
     \pause
     \item A novel distributed evaluation algorithm based on CORE.
   \end{itemize}
 \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preliminaries}

\begin{frame}{Event, stream, and complex event}
  \begin{block}{Event}
    Named mapping between attributes and values.
  \end{block}
  \begin{block}{Stream}
    Possibly infinite sequence $S = t_{0}t_{1}t_{2}\ldots$ of events.
  \end{block}
  \begin{block}{Complex Event}
    A pair $C = ([i,j], D)$ where $i \le j \in \mathbb{N}$ and $D$ is a subset of $\{i, \ldots, j\}$.
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{CEL: syntax and semantics}
  \begin{block}{Complex Event Logic}
    Formal logic that is built from the common operators in the literature of CER.
    \begin{equation*}
      \varphi := R    \ | \ \varphi \ \text{AS} \ X    \ | \    \varphi \ \text{FILTER} \ X[P]  \ | \   \varphi \ \text{OR} \ \varphi   \ | \  \varphi ; \varphi    \ | \  \varphi+ \ | \ \pi_{L}(\varphi).
    \end{equation*}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[allowframebreaks, fragile]{CEQL: syntax and semantics}
  \begin{block}{Complex Event Query Language (CEQL)}
    CEQL is a practical CER language based on \emph{Complex Event Logic (CEL)}.
  \end{block}
  \begin{block}{Syntax}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=0pt, linenos=false, fontsize=\footnotesize]{text}
        SELECT        [selection strategy] <list of variables>
        FROM          <list of streams>
        WHERE         <CEL formula>
        (PARTITION BY <list of attributes>)?
        (WHITHIN      <time>)?
      \end{minted}
    \end{figure}
  \end{block}
  \begin{block}{Semantics}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=0pt, linenos=false, fontsize=\footnotesize]{text}
        SELECT        [selection strategy] <list of variables>
        FROM          <list of streams>
        WHERE         <CEL formula>
        (PARTITION BY <list of attributes>)?
        (WHITHIN      <time>)?
      \end{minted}
    \end{figure}
    \begin{enumerate}
      \item \code{FROM}
      \item \code{PARTITION BY}
      \item \code{WHERE}
      \item \code{SELECT}
      \item \code{WITHIN}
    \end{enumerate}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[allowframebreaks, fragile]{Computational model}
  \begin{block}{Complex Event Automaton (CEA)}
     A form of finite automaton that produces complex events.
  \end{block}
  \begin{definition}
  A tuple $\mathcal{A} = (Q, \Delta, q_{0}, F)$ where $Q$ is a finite set of states, $\Delta \subseteq Q \times \textbf{P} \times \{\bullet, \circ\} \times (Q \setminus \{ q_{0} \})$ is a finite transition, $q_{0} \in Q$ is the initial state, and $F \subseteq Q$ is the set of final states. We will denote transitions in $\Delta$ by $q \xrightarrow[]{P/m} q'$.
  \end{definition}
  \begin{example}
    \begin{figure}[H]
      \begin{minted}[xleftmargin=0pt, linenos=false, fontsize=\footnotesize]{text}
    SELECT *
    FROM warehouse
    WHERE (T as t1; T+ as ts)
    FILTER t1[val < 30]
      AND ts[val > 30]
      \end{minted}
    \end{figure}
    \begin{figure}[H]
      \centering
      \inputtikz{cea}
    \end{figure}
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Distributed CER}

\begin{frame}{Distributed CER framework}
  \begin{block}{Observations}
    \begin{itemize}
        \pause
        \item CORE's sequential evaluation of CEA is \emph{fast}.
          \begin{itemize}
            \item Big overhead when distributed.
          \end{itemize}
        \pause
        \item The automaton model is \emph{limited to unary predicates}.
          \begin{itemize}
            \item Binary predicates: \code{t1[id] = h1[id]}
            \item Second-order predicates: the sequence of \code{t[val]} must monotonically increase
          \end{itemize}
        \pause
        \item The \emph{enumeration} process is still slow.
   \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Distributed CER framework}
  \begin{block}{Ideas}
    \begin{itemize}
        \item<1> Evaluate CEA sequentially.
        \item<2> Filter complex predicates distributedly.
        \item<3> Enumerate distributedly.
   \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Distributed CER framework}
  \begin{block}{Proposal}
    \begin{figure}[H]
      \centering
      \resizebox{!}{0.7\textheight}{%
        \inputtikz{framework}
      }
    \end{figure}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Distributed CER Engine (CER)}
  \begin{block}{Overview}
    \begin{figure}[H]
      \centering
      \resizebox{\textwidth}{!}{%
        \inputtikz{dcere}
      }
    \end{figure}
  \end{block}
\end{frame}

\begin{frame}{Distributed CER Engine (CER)}
  \begin{block}{Selection Strategies}
    \begin{itemize}
        \item<1> Round Robin (RR)
        \item<2> Power of Two Choices (PoTC)
        \item<3> Exact Search (ES)
        \item<4> Maximal Complex Event Enumeration (MCEE)
   \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Distributed CORE (DCORE)}
  \begin{block}{Overview}
    \begin{figure}[H]
      \centering
      \resizebox{\textwidth}{!}{%
        \inputtikz{dcore}
      }
    \end{figure}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Distributed Evaluation Algorithm}
% Explain goal
% Explain tECS
% Explain union lists
% Explain hash tables
% Explain evaluation algorithm by means of figures
% Explain enumeration procedure by means of figures
% Do not mention theorems nor pseudocode


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Experiments}

\begin{frame}{DCORE in a nutshell}
  \begin{block}{Overview}
    \begin{itemize}
      \item To run on the JVM.
      \item Open source and available at \url{https://github.com/dtim-upc/DCORE}.
      \item Depends on our fork of CORE \url{https://github.com/dtim-upc/CORE2/tree/distributed_enumeration}.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{DCORE in a nutshell}
  \begin{block}{DCORE}
    \begin{itemize}
      \item Implemented in Scala 2.12.
      \item Built on top of Akka Cluster.
      \item Compiled with Sbt.
      \item Provided as a white box.
      \item Rigorously tested.
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[allowframebreaks,fragile]{Experimental setup}
  \begin{block}{Goal}
    Compare DCERE, DCORE, and CORE.
  \end{block}
  \begin{block}{Settings}
    Server equipped with a 12 cores Intel i7-8700, 32Gb of RAM, Linux 5.15.
  \end{block}
  \begin{block}{Setup}
    \begin{itemize}
      \item We compare systems with respect to their performance.
      \item Reported numbers are averages taken over three repetitions of each experiment.
      \item Synthetic datasets.
    \end{itemize}
  \end{block}
  \begin{block}{Datasets}
    \begin{figure}[H]
      \centering
      \begin{subfigure}[c]{0.32\textwidth}
        \centering
        \begin{minted}[fontsize=\footnotesize, linenos=false, autogobble]{text}
          SELECT *
          FROM S
          WHERE P
          FILTER A[id] = B[id]
          WITHIN 100 events
        \end{minted}
      \end{subfigure}
      \begin{subfigure}[t]{0.32\textwidth}
        \begin{tabular}{l l}
          \hline
          $Q_{1}:$ & $P = A;B;C$ \\
          \hline
          $Q_{2}:$ & $P = A;B+;C$ \\
          \hline
          $Q_{3}:$ & $P = A+;B+;C$ \\
          \hline
        \end{tabular}
      \end{subfigure}
      \hfill
      \begin{subfigure}[c]{0.32\textwidth}
        \centering
        \begin{tabular}{l c}
          \hline
          $S_{1}:$ & A,A$\ldots$B,B$\ldots$C\\
          \hline
          $S_{2}:$ & A,B,B,B$\ldots$C\\
          \hline
          $S_{3}:$ & A,B,A,B$\ldots$C\\
          \hline
        \end{tabular}
      \end{subfigure}
    \end{figure}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%

% Maybe CV can be removed

\begin{frame}{Experiments}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions and Future Work}
% Just copy/paste Contributions I and II
% Explain future work with a list


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[allowframebreaks]
  \frametitle{Bibliography}
  \bibliographystyle{unsrt}
  \bibliography{bibliography}
\end{frame}

\end{document}

